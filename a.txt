ä»•æ§˜æ›¸
å¤§å¯Œè±ªã‚²ãƒ¼ãƒ ã«ãŠã‘ã‚‹ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰ã¨ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã®å½¹å‰²





1. ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ï¼ˆã‚µãƒ¼ãƒãƒ¼ï¼‰



å½¹å‰²: ã‚²ãƒ¼ãƒ ã®ã€Œè„³ã€ã§ã‚ã‚Šã€Œç®¡ç†è€…ã€ã€‚ã‚²ãƒ¼ãƒ ã®é€²è¡Œã‚’å¸ã‚Šã€ãƒ«ãƒ¼ãƒ«ã‚’é©ç”¨ã—ã€ã™ã¹ã¦ã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®çŠ¶æ…‹ã‚’ä¸€å…ƒçš„ã«ç®¡ç†ã—ã¾ã™ã€‚ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‹ã‚‰ã®ãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’å—ã‘å–ã‚Šã€ã‚²ãƒ¼ãƒ ãƒ­ã‚¸ãƒƒã‚¯ã«åŸºã¥ã„ã¦å‡¦ç†ã‚’è¡Œã„ã€çµæœã‚’ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã«é€šçŸ¥ã—ã¾ã™ã€‚

ä¸»ãªä»•äº‹:

ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®æ¥ç¶šãƒ»ç®¡ç†: è¤‡æ•°ã®ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‹ã‚‰ã®æ¥ç¶šã‚’å—ã‘ä»˜ã‘ã€ãã‚Œãã‚Œã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’è­˜åˆ¥ãƒ»ç®¡ç†ã—ã¾ã™ã€‚

ã‚²ãƒ¼ãƒ ã®çŠ¶æ…‹ç®¡ç†:

èª°ãŒã©ã®æ‰‹æœ­ã‚’æŒã£ã¦ã„ã‚‹ã‹ã€‚

ç¾åœ¨ã€å ´ã«ã©ã‚“ãªã‚«ãƒ¼ãƒ‰ãŒå‡ºã¦ã„ã‚‹ã‹ã€‚

ç¾åœ¨ã®æ‰‹ç•ªã¯èª°ã‹ã€‚

ã‚²ãƒ¼ãƒ ã®ãƒ•ã‚§ãƒ¼ã‚ºï¼ˆå¾…æ©Ÿä¸­ã€ã‚²ãƒ¼ãƒ ä¸­ã€çµ‚äº†ãªã©ï¼‰ã€‚

ãƒ‘ã‚¹ã®å›æ•°ã€é©å‘½ã®çŠ¶æ…‹ã€ç¸›ã‚Šã®çŠ¶æ…‹ãªã©ã€ãƒ«ãƒ¼ãƒ«ã«å¿…è¦ãªã™ã¹ã¦ã®æƒ…å ±ã€‚

ã‚²ãƒ¼ãƒ ãƒ­ã‚¸ãƒƒã‚¯ã®å®Ÿè£…:

ã‚«ãƒ¼ãƒ‰ã®ã‚·ãƒ£ãƒƒãƒ•ãƒ«ã€é…å¸ƒã€‚

ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‹ã‚‰ã®ã€Œã‚«ãƒ¼ãƒ‰ã‚’å‡ºã™ã€ã€Œãƒ‘ã‚¹ã™ã‚‹ã€ã¨ã„ã£ãŸã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã®æ¤œè¨¼ï¼ˆæ­£ã—ã„ã‚«ãƒ¼ãƒ‰ã‹ã€ãƒ«ãƒ¼ãƒ«ã«å‰‡ã£ã¦ã„ã‚‹ã‹ï¼‰ã€‚

æ‰‹ç•ªã®é€²è¡Œç®¡ç†ã€‚

å ´ã®ã‚«ãƒ¼ãƒ‰ã®æ›´æ–°ã€æµã‚Œã‚‹å‡¦ç†ã€‚

å‹æ•—åˆ¤å®šã€é †ä½æ±ºå®šã€‚

å„ç¨®ãƒ­ãƒ¼ã‚«ãƒ«ãƒ«ãƒ¼ãƒ«ã®é©ç”¨ï¼ˆ8åˆ‡ã‚Šã€é©å‘½ã€éƒ½è½ã¡ãªã©ï¼‰ã€‚

ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã¸ã®æƒ…å ±é€šçŸ¥: ã‚²ãƒ¼ãƒ ã®çŠ¶æ…‹å¤‰åŒ–ï¼ˆæ‰‹ç•ªå¤‰æ›´ã€ã‚«ãƒ¼ãƒ‰ãŒå‡ºã•ã‚ŒãŸã€æ‰‹æœ­æ›´æ–°ã€ã‚²ãƒ¼ãƒ çµ‚äº†ãªã©ï¼‰ã‚’é©åˆ‡ãªã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã«é€ä¿¡ã—ã¾ã™ã€‚

åŠ´åŠ›ï¼ˆéª¨çµ„ã¿æ®µéšï¼‰:

é«˜ã„ã€‚ã‚²ãƒ¼ãƒ ã®æ ¸ã¨ãªã‚‹ãƒ­ã‚¸ãƒƒã‚¯ã¨ã€è¤‡æ•°ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã¨ã®é€šä¿¡å‡¦ç†ãŒé›†ä¸­ã™ã‚‹ãŸã‚ã€ä¸€ç•ªè¤‡é›‘ã§é‡è¦ã§ã™ã€‚ãƒ‡ãƒãƒƒã‚°ã‚‚ã‚µãƒ¼ãƒãƒ¼å´ãŒä¸»ã«ãªã‚Šã¾ã™ã€‚ã¾ãšã¯ã‚·ãƒ³ãƒ—ãƒ«ãªãƒ«ãƒ¼ãƒ«ã§å®Ÿè£…ã—ã€å¾ã€…ã«è¤‡é›‘ãªãƒ«ãƒ¼ãƒ«ã‚’è¿½åŠ ã—ã¦ã„ãå½¢ã«ãªã‚‹ã§ã—ã‚‡ã†ã€‚CUIã§ã‚‚GUIã§ã‚‚ã€ã“ã®éƒ¨åˆ†ã¯å¿…é ˆã§ã™ã€‚



2. ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰ï¼ˆã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆï¼‰



å½¹å‰²: ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒã‚²ãƒ¼ãƒ ã‚’æ“ä½œã—ã€ç¾åœ¨ã®ã‚²ãƒ¼ãƒ ã®çŠ¶æ…‹ã‚’ç¢ºèªã™ã‚‹ãŸã‚ã®ã€Œçª“å£ã€ã€‚ã‚µãƒ¼ãƒãƒ¼ã‹ã‚‰é€ã‚‰ã‚Œã¦ãã‚‹æƒ…å ±ã‚’å…ƒã«ã€ç”»é¢è¡¨ç¤ºã‚’æ›´æ–°ã—ã€ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®æ“ä½œã‚’ã‚µãƒ¼ãƒãƒ¼ã«ä¼ãˆã¾ã™ã€‚

ä¸»ãªä»•äº‹:

ã‚µãƒ¼ãƒãƒ¼ã¸ã®æ¥ç¶šãƒ»åˆ‡æ–­: ã‚²ãƒ¼ãƒ é–‹å§‹æ™‚ã«ã‚µãƒ¼ãƒãƒ¼ã«æ¥ç¶šã—ã€çµ‚äº†æ™‚ã«åˆ‡æ–­ã—ã¾ã™ã€‚

ã‚µãƒ¼ãƒãƒ¼ã‹ã‚‰ã®æƒ…å ±å—ä¿¡ãƒ»è¡¨ç¤º:

è‡ªåˆ†ã®æ‰‹æœ­ã‚’è¡¨ç¤ºã€‚

å ´ã«å‡ºã¦ã„ã‚‹ã‚«ãƒ¼ãƒ‰ã‚’è¡¨ç¤ºã€‚

ç¾åœ¨ã®æ‰‹ç•ªãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’è¡¨ç¤ºã€‚

ä»–ã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®è¡Œå‹•ï¼ˆã€Œã€‡ã€‡ãŒã‚«ãƒ¼ãƒ‰ã‚’å‡ºã—ãŸã€ã€Œâ–³â–³ãŒãƒ‘ã‚¹ã—ãŸã€ãªã©ï¼‰ã‚’ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã§è¡¨ç¤ºã€‚

ã‚²ãƒ¼ãƒ ã®çµ‚äº†ã‚„å‹æ•—ã‚’é€šçŸ¥ã€‚

ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‹ã‚‰ã®å…¥åŠ›å—ä»˜ãƒ»ã‚µãƒ¼ãƒãƒ¼ã¸ã®é€ä¿¡:

è‡ªåˆ†ã®æ‰‹æœ­ã‹ã‚‰ã‚«ãƒ¼ãƒ‰ã‚’é¸æŠã—ã¦å‡ºã™æ©Ÿèƒ½ã€‚

ãƒ‘ã‚¹ã™ã‚‹æ©Ÿèƒ½ã€‚

ï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰ãƒãƒ£ãƒƒãƒˆå…¥åŠ›æ©Ÿèƒ½ã€‚

ã“ã‚Œã‚‰ã®å…¥åŠ›ã‚’ã‚µãƒ¼ãƒãƒ¼ã«æŒ‡å®šã•ã‚ŒãŸå½¢å¼ï¼ˆJSONãªã©ï¼‰ã§é€ä¿¡ã—ã¾ã™ã€‚

åŠ´åŠ›ï¼ˆéª¨çµ„ã¿æ®µéšï¼‰:

ä¸­ç¨‹åº¦ã€‚CUIï¼ˆã‚³ãƒãƒ³ãƒ‰ãƒ©ã‚¤ãƒ³ï¼‰ã§å®Ÿè£…ã™ã‚‹é™ã‚Šã¯ã€å…¥åŠ›ã¨å‡ºåŠ›ã®ãƒ†ã‚­ã‚¹ãƒˆå‡¦ç†ãªã®ã§æ¯”è¼ƒçš„ã‚·ãƒ³ãƒ—ãƒ«ã§ã™ã€‚ãŸã ã—ã€ã‚µãƒ¼ãƒãƒ¼ã‹ã‚‰é€ã‚‰ã‚Œã¦ãã‚‹æ§˜ã€…ãªç¨®é¡ã®æƒ…å ±ã‚’æ­£ã—ãè§£é‡ˆã—ã€é©åˆ‡ã«è¡¨ç¤ºãƒ»æ“ä½œã«åæ˜ ã•ã›ã‚‹ãƒ­ã‚¸ãƒƒã‚¯ã¯å¿…è¦ã«ãªã‚Šã¾ã™ã€‚GUIã‚’å®Ÿè£…ã™ã‚‹å ´åˆã¯ã€åŠ´åŠ›ã¯å¤§å¹…ã«ä¸ŠãŒã‚Šã¾ã™ã€‚





ã‚·ãƒ³ãƒ—ãƒ«ãªæ çµ„ã¿ã¨åŠ´åŠ›ã®é…åˆ†ï¼ˆéª¨çµ„ã¿ãƒ•ã‚§ãƒ¼ã‚ºï¼‰



æ çµ„ã¿

ä»•äº‹å†…å®¹ï¼ˆã‚·ãƒ³ãƒ—ãƒ«ç‰ˆï¼‰

åŠ´åŠ›ã®ç›®å®‰ï¼ˆéª¨çµ„ã¿ãƒ•ã‚§ãƒ¼ã‚ºï¼‰

ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰

- ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‹ã‚‰ã®æ¥ç¶šå—ä»˜ã€ç®¡ç†



- ã‚«ãƒ¼ãƒ‰ã®ç”Ÿæˆã€ã‚·ãƒ£ãƒƒãƒ•ãƒ«ã€é…å¸ƒ



- æ‰‹ç•ªã®ç®¡ç†ã€å ´ã®ã‚«ãƒ¼ãƒ‰ã®çŠ¶æ…‹ç®¡ç†



- æœ€ä½é™ã®ãƒ«ãƒ¼ãƒ«åˆ¤å®šï¼ˆå‡ºã›ã‚‹æšæ•°ã€å¼·å¼±ã®ã¿ï¼‰



- ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã¸ã®çŠ¶æ…‹é€šçŸ¥ï¼ˆJSONå½¢å¼ï¼‰

ç´„ 60-70%

ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰

- ã‚µãƒ¼ãƒãƒ¼ã¸ã®æ¥ç¶šã€ãƒ‡ãƒ¼ã‚¿é€å—ä¿¡



- CUIã§ã®æ‰‹æœ­ã€å ´ã®ã‚«ãƒ¼ãƒ‰ã€ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸è¡¨ç¤º



- CUIã§ã®ã‚«ãƒ¼ãƒ‰é¸æŠã€ãƒ‘ã‚¹å…¥åŠ›ã€ã‚µãƒ¼ãƒãƒ¼ã¸ã®é€ä¿¡

ç´„ 30-40%

ãƒã‚¤ãƒ³ãƒˆ:

ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ãŒè‚: éª¨çµ„ã¿æ®µéšã§ã¯ã€ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã§ã‚²ãƒ¼ãƒ ã®æ ¸å¿ƒã¨ãªã‚‹ãƒ­ã‚¸ãƒƒã‚¯ã¨ã€è¤‡æ•°ã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒåŒæ™‚ã«å‚åŠ ã§ãã‚‹é€šä¿¡åŸºç›¤ã‚’æ§‹ç¯‰ã™ã‚‹ã“ã¨ã«æœ€ã‚‚åŠ´åŠ›ãŒã‹ã‹ã‚Šã¾ã™ã€‚

ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰ã¯CUIã§ç°¡ç•¥åŒ–: æœ€åˆã¯ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰ã®è¦‹ãŸç›®ã‚„æ“ä½œæ€§ã‚’CUIã«é™å®šã™ã‚‹ã“ã¨ã§ã€é–‹ç™ºã®æ‰‹é–“ã‚’å¤§å¹…ã«å‰Šæ¸›ã—ã€ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã®æ ¸ã¨ãªã‚‹éƒ¨åˆ†ã«é›†ä¸­ã§ãã¾ã™ã€‚

åˆ†æ¥­ã®å ´åˆ: ã‚‚ã—ãƒãƒ¼ãƒ ã§é–‹ç™ºã™ã‚‹ãªã‚‰ã€ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰æ‹…å½“ã¨ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰æ‹…å½“ã«åˆ†ã‘ã‚‹ã“ã¨ã§åŠ¹ç‡ãŒä¸ŠãŒã‚Šã¾ã™ãŒã€æœ€åˆã¯ã©ã¡ã‚‰ã‹ãŒä¸¡æ–¹ã‚’ã‚ã‚‹ç¨‹åº¦ç†è§£ã—ã¦ã„ã‚‹ã¨ã‚¹ãƒ ãƒ¼ã‚ºã§ã™ã€‚

ã“ã®ã‚·ãƒ³ãƒ—ãƒ«ãªæ çµ„ã¿ã§ã¾ãšå‹•ãã‚‚ã®ã‚’ä½œã‚Šã€ãã®å¾Œã€ãƒ«ãƒ¼ãƒ«ã‚’è¿½åŠ ã—ãŸã‚Šã€CUIã‹ã‚‰GUIã¸ç§»è¡Œã—ãŸã‚Šã™ã‚‹éš›ã«ã€ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰ã®åŠ´åŠ›ãŒå¢—ãˆã¦ã„ãã‚¤ãƒ¡ãƒ¼ã‚¸ã§ã™ã€‚



ğŸŸ¡ ä»Šå¾Œè¿½åŠ ã™ã¹ãæ®‹ã‚Šæ©Ÿèƒ½ï¼ˆè¨­è¨ˆæ›¸ï¼ã‚¯ãƒ©ã‚¹å›³ã®è¦³ç‚¹ã‹ã‚‰ï¼‰
æ©Ÿèƒ½	å†…å®¹	çŠ¶æ…‹	å‚™è€ƒ
ğŸ” ã‚²ãƒ¼ãƒ ãƒªã‚»ãƒƒãƒˆæ©Ÿèƒ½	å‹è€…æ±ºå®šå¾Œã€2ã‚²ãƒ¼ãƒ ç›®ã‚’é–‹å§‹ã§ãã‚‹ä»•çµ„ã¿	æœªå®Ÿè£…	GameRoom ã‚’å†åˆ©ç”¨ã§ãã‚‹ã‚ˆã†ã«ã™ã‚‹å¿…è¦ã‚ã‚Š
ğŸ§  NPCã®ç°¡æ˜“ãƒ­ã‚¸ãƒƒã‚¯	NPCãŒè‡ªå‹•ã§ã‚«ãƒ¼ãƒ‰ã‚’å‡ºã™ or ãƒ‘ã‚¹ã™ã‚‹	æœªå®Ÿè£…	ç¾åœ¨NPCã¯ä½•ã‚‚è¡Œå‹•ã—ãªã„
â™»ï¸ å†æ¥ç¶šå‡¦ç†	æ¥ç¶šãŒåˆ‡ã‚ŒãŸãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒå¾©å¸°ã§ãã‚‹	æœªå®Ÿè£…	WebSocketåˆ‡æ–­å¾Œã®å‡¦ç†æ‹¡å¼µãŒå¿…è¦
ğŸ“ è¦³æˆ¦ãƒ¢ãƒ¼ãƒ‰	è¦³æˆ¦ã®ã¿ã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ï¼ˆisSpectatorï¼‰	ä»»æ„	UMLã«ã‚ã‚Œã°ã ãŒä»Šã¯å„ªå…ˆåº¦ä½
ğŸ§© ãƒ­ãƒ¼ã‚«ãƒ«ãƒ«ãƒ¼ãƒ«ã®å°å…¥	8åˆ‡ã‚Šãƒ»é©å‘½ãªã©å¤§å¯Œè±ªãƒ«ãƒ¼ãƒ«	ä»»æ„	ã‚¹ãƒ†ãƒƒãƒ—ã‚¢ãƒƒãƒ—é …ç›®ï¼ˆä»Šã¯ã‚·ãƒ³ãƒ—ãƒ«ä»•æ§˜ï¼‰
ğŸ§‘â€ğŸ¤â€ğŸ§‘ UIã®æ”¹å–„	ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ã‚¿ãƒ¼ãƒ³è¡¨ç¤ºãƒ»æ®‹ã‚Šæ‰‹æœ­æšæ•°ãªã©	ä¸€éƒ¨æ¸ˆ	æ”¹å–„ä½™åœ°ã‚ã‚Šï¼ˆã‚ˆã‚Šè¦–è¦šçš„ã«ï¼‰
ğŸ§ª ãƒ†ã‚¹ãƒˆå°å…¥	å˜ä½“ãƒ†ã‚¹ãƒˆãƒ»ã‚·ãƒŠãƒªã‚ªãƒ†ã‚¹ãƒˆ	æœªç€æ‰‹	æœ¬æ ¼é–‹ç™ºã§ã¯å¿…è¦ã«ãªã‚‹å·¥ç¨‹


ğŸ” ã‚²ãƒ¼ãƒ å†ã‚¹ã‚¿ãƒ¼ãƒˆæ©Ÿèƒ½
ã€€â†’ ã‚²ãƒ¼ãƒ çµ‚äº†å¾Œã«æ–°ã—ã„ã‚²ãƒ¼ãƒ ã‚’åŒã˜ãƒ«ãƒ¼ãƒ ã§å§‹ã‚ã‚‰ã‚Œã‚‹ã‚ˆã†ã«ã™ã‚‹ã€‚
ã€€â†’ resetGame() ãªã©ã‚’ GameRoom ã«è¿½åŠ ã€clientå´ã«ã€Œå†ã‚¹ã‚¿ãƒ¼ãƒˆã€ãƒœã‚¿ãƒ³å®Ÿè£…ã€‚

å‰å›gptã®ãƒ¡ãƒ¢ä»¥ä¸‹(ã“ã‚Œã¯é–“é•ã£ã¦ã„ã‚‹éƒ¨åˆ†ã‚‚ã‚ã‚‹å¯èƒ½æ€§ãŒã‚ã‚‹ã“ã¨ã«ç•™æ„ã—ã¦ãã ã•ã„)
âœ… æ§‹ç¯‰ç’°å¢ƒï¼ˆãƒ­ãƒ¼ã‚«ãƒ«é–‹ç™ºç’°å¢ƒï¼‰
é …ç›®	å†…å®¹
OS	Windowsï¼ˆCode Page: 65001 / UTF-8ï¼‰
å®Ÿè¡Œç’°å¢ƒ	Node.js (server.js ã«ã‚ˆã‚‹WebSocketã‚µãƒ¼ãƒãƒ¼)
ä½¿ç”¨ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸	express, ws
ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªæ§‹æˆ	C:\dgf-online\ é…ä¸‹ã«ä»¥ä¸‹ãŒå­˜åœ¨ï¼š
â”œâ”€ server/ â†’ server.js, GameRoom.js
â””â”€ public/ â†’ client.js, index.html ãªã©
èµ·å‹•æ–¹æ³•	node server/server.js ã«ã¦ãƒ­ãƒ¼ã‚«ãƒ«ã‚µãƒ¼ãƒãƒ¼èµ·å‹•
ãƒãƒ¼ãƒˆ	http://localhost:3000 ã§æ¥ç¶šç¢ºèªæ¸ˆã¿
ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆé€šä¿¡	WebSocketï¼ˆws://localhost:3000ï¼‰ã§ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ é€šä¿¡
å®Ÿè¡Œãƒ­ã‚°	ã‚µãƒ¼ãƒãƒ¼èµ·å‹• http://localhost:3000 ç¢ºèªæ¸ˆã¿
ãƒ–ãƒ©ã‚¦ã‚¶å‹•ä½œ	ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆç”»é¢è¡¨ç¤ºãƒ»ã‚²ãƒ¼ãƒ é–‹å§‹å¯èƒ½ï¼ˆé€šä¿¡ã¯å‹•ä½œï¼‰

ğŸ“Œ ç¾çŠ¶ã®é€²æ—ã¨èª²é¡Œ
ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹	å†…å®¹
âœ… ã‚²ãƒ¼ãƒ ãƒ«ãƒ¼ãƒ ä½œæˆ	ä¸»å‚¬è€…ãŒéƒ¨å±‹ã‚’ä½œæˆã—ã€æœ€å¤§äººæ•°è¨­å®šå¯èƒ½
âœ… ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼å‚åŠ 	ä»–ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒå‚åŠ ã€‚äººæ•°ä¸è¶³æ™‚ã¯ NPC è‡ªå‹•è£œå……
âœ… ã‚²ãƒ¼ãƒ é–‹å§‹å‡¦ç†	ã€Œã‚¹ã‚¿ãƒ¼ãƒˆãƒœã‚¿ãƒ³ã€æŠ¼ä¸‹ã§å…¨ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã«æ‰‹æœ­é…å¸ƒ
âœ… æ‰‹æœ­è¡¨ç¤º	ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆå´ã«ã‚«ãƒ¼ãƒ‰ãŒãƒœã‚¿ãƒ³å½¢å¼ã§è¡¨ç¤ºã•ã‚Œã‚‹
âœ… å‹åˆ©åˆ¤å®š	ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®æ‰‹æœ­ãŒç©ºã«ãªã£ãŸã‚‰å‹åˆ©ã¨åˆ¤å®šã—ã€game-ended ã‚’é€ä¿¡
âš ï¸ æœªç¢ºèªã¾ãŸã¯ä¸å®‰å®š	ä»¥ä¸‹ã®æŒ™å‹•ãŒã¾ã æ¤œè¨¼ãƒ»èª¿æ•´ä¸­ï¼š
ãƒ»ã‚¿ãƒ¼ãƒ³çµ‚äº†å¾Œã€æ¬¡ã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã® your-turn ãŒæ­£ã—ãå±Šã‹ãªã„å ´åˆãŒã‚ã‚‹
ãƒ»ä»–ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã«ã‚«ãƒ¼ãƒ‰å‡ºã—ãŒåæ˜ ã•ã‚Œãªã„ã“ã¨ãŒã‚ã‚‹
ãƒ»NPCã®è‡ªå‹•ã‚¿ãƒ¼ãƒ³å‡¦ç†ã¯æœªå®Ÿè£…ï¼ˆç¾çŠ¶ã§ã¯å¾…ã¡ã®ã¾ã¾ï¼‰

ğŸ¯ æ¬¡ã«å®Ÿè£…ãƒ»ç¢ºèªã™ã¹ãé …ç›®ï¼ˆç›®å®‰ï¼‰
 å‡ºã—ãŸã‚«ãƒ¼ãƒ‰ãŒä»–ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ç”»é¢ã«ã‚‚æ­£ã—ãåæ˜ ã•ã‚Œã‚‹ã‹ç¢ºèª

 ã‚¿ãƒ¼ãƒ³ãŒå¾ªç’°ã™ã‚‹ã‚ˆã†ã« your-turn é€šçŸ¥ãŒé€£æºã—ã¦ã„ã‚‹ã‹ãƒ†ã‚¹ãƒˆ

 NPCã®è‡ªå‹•ã‚«ãƒ¼ãƒ‰å‡ºã—ï¼ˆAIãƒ­ã‚¸ãƒƒã‚¯ or ãƒ©ãƒ³ãƒ€ãƒ ï¼‰å®Ÿè£…ï¼ˆå¿…è¦ã«å¿œã˜ã¦ï¼‰

 UIãƒªã‚»ãƒƒãƒˆï¼2ã‚²ãƒ¼ãƒ ç›®ä»¥é™ã®å‡¦ç†ç¢ºèª

ğŸ§­ å¼•ãç¶™ãã®ãŸã‚ã®ä¸€è¨€ãƒ¡ãƒ¢ï¼ˆãƒ†ãƒ³ãƒ—ãƒ¬ï¼‰
ã“ã®ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã¯ Node.js + WebSocket ã‚’ç”¨ã„ãŸã€Œå¤§å¯Œè±ªã‚ªãƒ³ãƒ©ã‚¤ãƒ³ã‚²ãƒ¼ãƒ ã€ã§ã™ã€‚
ç¾æ™‚ç‚¹ã§ã‚²ãƒ¼ãƒ ã‚¹ã‚¿ãƒ¼ãƒˆã€œå‹åˆ©åˆ¤å®šã¾ã§ã¯ä¸€é€šã‚Šé€šã£ã¦ãŠã‚Šã€æ®‹ã‚‹èª²é¡Œã¯ã‚¿ãƒ¼ãƒ³åŒæœŸã¨ä»–ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã¸ã®ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ åæ˜ ã§ã™ã€‚
NPCã®ãƒ­ã‚¸ãƒƒã‚¯ã‚„å†è©¦åˆæ©Ÿèƒ½ã¯å¾Œå›ã—ã§ã€ã¾ãšã¯1ã‚²ãƒ¼ãƒ ãŒã‚¹ãƒ ãƒ¼ã‚ºã«é€²è¡Œã™ã‚‹ã“ã¨ã‚’å„ªå…ˆã—ã¦ã„ã¾ã™ã€‚



ä¿®æ­£ã—ã¦ã»ã—ã„ç‚¹
ãƒ«ãƒ¼ãƒ ã«å…¥ã£ãŸæ™‚ç‚¹ã§æšæ•°ã¯underfinedã¨è¡¨ç¤ºã•ã‚Œã‚‹ã®ã§ã™ãŒã€é–‹å§‹ã•ã‚Œã‚‹ã¾ã§ã¯ç©ºç™½ã§ä½•ã‚‚è¡¨ç¤ºã—ãªã„è¨­å®šã«å¤‰æ›´ã—ã¦ãã ã•ã„
ãã‚Œã¨ä¸€ã¤å‰ã¾ã§ã¯ã‚²ãƒ¼ãƒ ãŒãƒ—ãƒ¬ãƒ¼ã§ãã¦ã„ãŸã®ã§ã™ãŒã€ä»Šå›ã¯ã‚«ãƒ¼ãƒ‰ã‚’å‡ºã—ãŸã¨ãŸã‚“ã«ã™ã¹ã¦ã®ã‚«ãƒ¼ãƒ‰ãŒé¸æŠã§ããªããªã‚Šã€ã‚²ãƒ¼ãƒ ãŒé€²ã‚ãªããªã‚Šã¾ã—ãŸã€‚cpuãŒé¸æŠã‚’ã›ãšã«ã‚¹ã‚¿ãƒƒã‚¯ã—ã¦ã„ã‚‹ã®ã§ã¯ï¼Ÿ
ä¸€ã¤å‰ã§ã¯gameroom.jsã¯ã‚³ãƒ¼ãƒ‰æ•°ãŒã‘ã£ã“ã†ã‚ã£ãŸã®ã§ã™ãŒã‚ãªãŸãŒæ¶ˆã—ã¦ã—ã¾ã£ãŸã›ã„ã§ã¯ï¼Ÿã‚³ãƒ¼ãƒ‰ã‚’è²¼ã£ãŸæ–¹ãŒã„ã„ã§ã™ã‹ï¼Ÿã‚³ãƒ¼ãƒ‰ã‚’æ¯å›ãƒ¡ãƒ¢ãƒªã«ä¿å­˜ã—ã¦ã‚‚ã‚‰ã†ã“ã¨ã¯ã§ãã¾ã›ã‚“ã‹ï¼Ÿæ¯å›ã“ã¡ã‚‰ãŒupã™ã‚‹ã®ã¯å¤§å¤‰ã§ã™

ä»¥ä¸‹ã‚³ãƒ¼ãƒ‰
public/client.js


let socket = null;

const joinForm = document.getElementById('join-form');
const joinSection = document.getElementById('join-section');
const gameSection = document.getElementById('game-section');
const handDiv = document.getElementById('hand');
const playerNameDisplay = document.getElementById('player-name');
const playerListDiv = document.getElementById('player-list');
const startBtn = document.getElementById('start-btn');
const fieldDiv = document.getElementById('field');
const showHandsCheckbox = document.getElementById('show-hands-checkbox');

const overlayLayer = document.getElementById('overlay-layer');
const overlayMsg = document.getElementById('overlay-msg');
const overlayEnterBtn = document.getElementById('overlay-enter-btn');
const overlayDeleteBtn = document.getElementById('overlay-delete-btn');

let currentRoomId = null;
let myName = "";
let myHand = [];
let currentTurnPlayerId = null;

let latestPlayerListData = null;
let joinMode = "create";
let gameStarted = false;

// localStorageã«å‰å›æƒ…å ±ãŒã‚ã‚Œã°å¾©å…ƒ
window.addEventListener('DOMContentLoaded', () => {
    const prevName = localStorage.getItem('dgf-playerName');
    const prevRoom = localStorage.getItem('dgf-roomId');
    if (prevName) document.getElementById('name').value = prevName;
    if (prevRoom) document.getElementById('room-id').value = prevRoom;

    if (prevName && prevRoom) {
        showOverlay(`å‰å›ã®ãƒ«ãƒ¼ãƒ æƒ…å ±ãŒè¦‹ã¤ã‹ã‚Šã¾ã—ãŸ<br>
            <b>åå‰ï¼š</b>${prevName}<br>
            <b>ãƒ«ãƒ¼ãƒ IDï¼š</b>${prevRoom}<br>
            ã“ã®ãƒ«ãƒ¼ãƒ ã§å¾©å¸°/å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ`);
    }
});

function showOverlay(message) {
    overlayMsg.innerHTML = message;
    overlayLayer.style.display = 'flex';
    document.body.classList.add('layer-active');
}
function hideOverlay() {
    overlayLayer.style.display = 'none';
    document.body.classList.remove('layer-active');
}

// å…¥ã‚‹ï¼ˆå¾©å¸°ï¼‰ãƒœã‚¿ãƒ³
overlayEnterBtn.onclick = () => {
    hideOverlay();
    document.getElementById('name').value = localStorage.getItem('dgf-playerName') || '';
    document.getElementById('room-id').value = localStorage.getItem('dgf-roomId') || '';
    joinForm.requestSubmit();
};
// å‰Šé™¤ãƒœã‚¿ãƒ³
overlayDeleteBtn.onclick = () => {
    hideOverlay();
    const roomId = localStorage.getItem('dgf-roomId');
    const name = localStorage.getItem('dgf-playerName');
    openSocket();
    socket.addEventListener('open', function onOpen() {
        socket.send(JSON.stringify({
            type: "delete-room",
            payload: {
                roomId,
                playerName: name
            }
        }));
        socket.close();
        localStorage.removeItem('dgf-playerName');
        localStorage.removeItem('dgf-roomId');
        alert("ãƒ«ãƒ¼ãƒ ã‚’å‰Šé™¤ã—ã¾ã—ãŸ");
    }, { once: true });
};

function openSocket() {
    if (socket && socket.readyState === 1) socket.close();
    socket = new WebSocket(`ws://${location.host}`);
    setupSocketEvents();
}
openSocket();

joinForm.addEventListener('submit', (e) => {
    e.preventDefault();
    const name = document.getElementById('name').value;
    const roomId = document.getElementById('room-id').value;
    const maxPlayers = parseInt(document.getElementById('max-players').value, 10);

    currentRoomId = roomId;
    myName = name;

    localStorage.setItem('dgf-playerName', name);
    localStorage.setItem('dgf-roomId', roomId);

    joinMode = "create";
    socket.send(JSON.stringify({
        type: 'create-room',
        payload: {
            roomId,
            playerName: name,
            maxPlayers
        }
    }));

    joinSection.style.display = 'none';
    gameSection.style.display = 'block';
    playerNameDisplay.textContent = `${name} ã•ã‚“ã®æ‰‹æœ­`;
});

function setupSocketEvents() {
    socket.addEventListener('message', (event) => {
        const data = JSON.parse(event.data);

        if (data.type === 'error' && data.message.includes('æ—¢ã«å­˜åœ¨')) {
            if (joinMode === "create") {
                joinMode = "join";
                socket.send(JSON.stringify({
                    type: 'join-room',
                    payload: {
                        roomId: currentRoomId,
                        playerName: myName
                    }
                }));
                return;
            }
        }

        if (data.type === 'hand') {
            myHand = data.cards;
            renderHand(myHand);
        }

        if (data.type === 'error') {
            alert(data.message);
        }

        if (data.type === 'game-started') {
            gameStarted = true;
            startBtn.style.display = "none";
            renderPlayerList(data.players, true, currentTurnPlayerId, showHandsCheckbox && showHandsCheckbox.checked, data);
        }

        if (data.type === 'field-card') {
            updateField(data.card);
        }

        if (data.type === 'your-turn') {
            if (data.isYourTurn) {
                enableHandButtons();
            } else {
                disableHandButtons();
            }
        }

        if (data.type === 'player-list') {
            currentTurnPlayerId = data.currentPlayerId;
            latestPlayerListData = data;
            if (gameStarted) startBtn.style.display = "none";
            renderPlayerList(
                data.players,
                false,
                data.currentPlayerId,
                showHandsCheckbox && showHandsCheckbox.checked,
                data
            );
        }

        if (data.type === 'game-ended') {
            alert(`ğŸ‰ ${data.winner} ã•ã‚“ãŒå‹åˆ©ã—ã¾ã—ãŸï¼`);
            disableAllButtons();
            localStorage.removeItem('dgf-playerName');
            localStorage.removeItem('dgf-roomId');
            gameStarted = false;
            startBtn.style.display = "";
        }
    });
}

if (showHandsCheckbox) {
    showHandsCheckbox.addEventListener('change', () => {
        if (latestPlayerListData) {
            renderPlayerList(
                latestPlayerListData.players,
                false,
                latestPlayerListData.currentPlayerId,
                showHandsCheckbox.checked,
                latestPlayerListData
            );
        }
    });
}

function renderHand(cards) {
    handDiv.innerHTML = '';
    cards.forEach((card) => {
        const btn = document.createElement('button');
        btn.textContent = card;
        btn.classList.add('card-btn');
        btn.disabled = true;

        btn.addEventListener('click', () => {
            socket.send(JSON.stringify({
                type: 'play-card',
                payload: {
                    roomId: currentRoomId,
                    card
                }
            }));
            btn.disabled = true;
        });
        handDiv.appendChild(btn);
    });

    const passBtn = document.createElement('button');
    passBtn.id = 'pass-button';
    passBtn.textContent = 'PASS';
    passBtn.disabled = true;
    passBtn.addEventListener('click', () => {
        const confirmed = confirm("æœ¬å½“ã«ãƒ‘ã‚¹ã—ã¾ã™ã‹ï¼Ÿ");
        if (confirmed) {
            socket.send(JSON.stringify({
                type: 'pass',
                payload: {
                    roomId: currentRoomId
                }
            }));
            passBtn.disabled = true;
        }
    });
    handDiv.appendChild(passBtn);
}

// showAllHands: trueãªã‚‰å„ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®æ‰‹æœ­å†…å®¹ã‚‚ä½µè¨˜
function renderPlayerList(players, isGameStart, turnPlayerId, showAllHands = false, playerListData = null) {
    if (!playerListDiv) return;
    playerListDiv.innerHTML = '<h3>å‚åŠ ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼</h3>';
    const ul = document.createElement('ul');
    let handsMap = {};
    if (showAllHands && playerListData && playerListData.players) {
        playerListData.players.forEach(p => {
            if (p.hand) handsMap[p.id] = p.hand;
        });
    }
    players.forEach(p => {
        let text = "";
        if ((typeof p.cardsLeft === "number") && !isGameStart) {
            text =
                p.isNPC ? `${p.name} (NPC) æ®‹${p.cardsLeft}æš` :
                (p.finished ? `${p.name}ï¼ˆä¸ŠãŒã‚Šï¼‰` : `${p.name} æ®‹${p.cardsLeft}æš`);
        } else if (isGameStart) {
            text =
                p.isNPC ? `${p.name} (NPC) æ®‹${p.cardsLeft ?? ''}æš` :
                (p.finished ? `${p.name}ï¼ˆä¸ŠãŒã‚Šï¼‰` : `${p.name} æ®‹${p.cardsLeft ?? ''}æš`);
        } else {
            text = p.isNPC ? `${p.name} (NPC)` : `${p.name}`;
        }
        if (showAllHands && handsMap && handsMap[p.id] && handsMap[p.id].length > 0) {
            text += ` [${handsMap[p.id].join(', ')}]`;
        }
        const li = document.createElement('li');
        if (turnPlayerId && p.id === turnPlayerId) {
            li.textContent = `â–·${text}`;
        } else {
            li.textContent = text;
        }
        if (myName && p.name === myName) li.style.fontWeight = "bold";
        ul.appendChild(li);
    });
    playerListDiv.appendChild(ul);
}

startBtn.addEventListener('click', () => {
    socket.send(JSON.stringify({
        type: 'start-game',
        payload: {
            roomId: currentRoomId
        }
    }));
    startBtn.disabled = true;
});

function updateField(card) {
    if (fieldDiv) {
        fieldDiv.innerHTML = `<h3>å ´ã®ã‚«ãƒ¼ãƒ‰: ${card}</h3>`;
    }
}

function enableHandButtons() {
    document.querySelectorAll('.card-btn').forEach(btn => btn.disabled = false);
    const passBtn = document.getElementById('pass-button');
    if (passBtn) passBtn.disabled = false;
}

function disableHandButtons() {
    document.querySelectorAll('.card-btn').forEach(btn => btn.disabled = true);
    const passBtn = document.getElementById('pass-button');
    if (passBtn) passBtn.disabled = true;
}

function disableAllButtons() {
    document.querySelectorAll('button').forEach(btn => {
        btn.disabled = true;
    });
}




public/game.html





let socket = null;

const joinForm = document.getElementById('join-form');
const joinSection = document.getElementById('join-section');
const gameSection = document.getElementById('game-section');
const handDiv = document.getElementById('hand');
const playerNameDisplay = document.getElementById('player-name');
const playerListDiv = document.getElementById('player-list');
const startBtn = document.getElementById('start-btn');
const fieldDiv = document.getElementById('field');
const showHandsCheckbox = document.getElementById('show-hands-checkbox');

const overlayLayer = document.getElementById('overlay-layer');
const overlayMsg = document.getElementById('overlay-msg');
const overlayEnterBtn = document.getElementById('overlay-enter-btn');
const overlayDeleteBtn = document.getElementById('overlay-delete-btn');

let currentRoomId = null;
let myName = "";
let myHand = [];
let currentTurnPlayerId = null;

let latestPlayerListData = null;
let joinMode = "create";
let gameStarted = false;

// localStorageã«å‰å›æƒ…å ±ãŒã‚ã‚Œã°å¾©å…ƒ
window.addEventListener('DOMContentLoaded', () => {
    const prevName = localStorage.getItem('dgf-playerName');
    const prevRoom = localStorage.getItem('dgf-roomId');
    if (prevName) document.getElementById('name').value = prevName;
    if (prevRoom) document.getElementById('room-id').value = prevRoom;

    if (prevName && prevRoom) {
        showOverlay(`å‰å›ã®ãƒ«ãƒ¼ãƒ æƒ…å ±ãŒè¦‹ã¤ã‹ã‚Šã¾ã—ãŸ<br>
            <b>åå‰ï¼š</b>${prevName}<br>
            <b>ãƒ«ãƒ¼ãƒ IDï¼š</b>${prevRoom}<br>
            ã“ã®ãƒ«ãƒ¼ãƒ ã§å¾©å¸°/å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ`);
    }
});

function showOverlay(message) {
    overlayMsg.innerHTML = message;
    overlayLayer.style.display = 'flex';
    document.body.classList.add('layer-active');
}
function hideOverlay() {
    overlayLayer.style.display = 'none';
    document.body.classList.remove('layer-active');
}

// å…¥ã‚‹ï¼ˆå¾©å¸°ï¼‰ãƒœã‚¿ãƒ³
overlayEnterBtn.onclick = () => {
    hideOverlay();
    document.getElementById('name').value = localStorage.getItem('dgf-playerName') || '';
    document.getElementById('room-id').value = localStorage.getItem('dgf-roomId') || '';
    joinForm.requestSubmit();
};
// å‰Šé™¤ãƒœã‚¿ãƒ³
overlayDeleteBtn.onclick = () => {
    hideOverlay();
    const roomId = localStorage.getItem('dgf-roomId');
    const name = localStorage.getItem('dgf-playerName');
    openSocket();
    socket.addEventListener('open', function onOpen() {
        socket.send(JSON.stringify({
            type: "delete-room",
            payload: {
                roomId,
                playerName: name
            }
        }));
        socket.close();
        localStorage.removeItem('dgf-playerName');
        localStorage.removeItem('dgf-roomId');
        alert("ãƒ«ãƒ¼ãƒ ã‚’å‰Šé™¤ã—ã¾ã—ãŸ");
    }, { once: true });
};

function openSocket() {
    if (socket && socket.readyState === 1) socket.close();
    socket = new WebSocket(`ws://${location.host}`);
    setupSocketEvents();
}
openSocket();

joinForm.addEventListener('submit', (e) => {
    e.preventDefault();
    const name = document.getElementById('name').value;
    const roomId = document.getElementById('room-id').value;
    const maxPlayers = parseInt(document.getElementById('max-players').value, 10);

    currentRoomId = roomId;
    myName = name;

    localStorage.setItem('dgf-playerName', name);
    localStorage.setItem('dgf-roomId', roomId);

    joinMode = "create";
    socket.send(JSON.stringify({
        type: 'create-room',
        payload: {
            roomId,
            playerName: name,
            maxPlayers
        }
    }));

    joinSection.style.display = 'none';
    gameSection.style.display = 'block';
    playerNameDisplay.textContent = `${name} ã•ã‚“ã®æ‰‹æœ­`;
});

function setupSocketEvents() {
    socket.addEventListener('message', (event) => {
        const data = JSON.parse(event.data);

        if (data.type === 'error' && data.message.includes('æ—¢ã«å­˜åœ¨')) {
            if (joinMode === "create") {
                joinMode = "join";
                socket.send(JSON.stringify({
                    type: 'join-room',
                    payload: {
                        roomId: currentRoomId,
                        playerName: myName
                    }
                }));
                return;
            }
        }

        if (data.type === 'hand') {
            myHand = data.cards;
            renderHand(myHand);
        }

        if (data.type === 'error') {
            alert(data.message);
        }

        if (data.type === 'game-started') {
            gameStarted = true;
            startBtn.style.display = "none";
            renderPlayerList(data.players, true, currentTurnPlayerId, showHandsCheckbox && showHandsCheckbox.checked, data);
        }

        if (data.type === 'field-card') {
            updateField(data.card);
        }

        if (data.type === 'your-turn') {
            if (data.isYourTurn) {
                enableHandButtons();
            } else {
                disableHandButtons();
            }
        }

        if (data.type === 'player-list') {
            currentTurnPlayerId = data.currentPlayerId;
            latestPlayerListData = data;
            if (gameStarted) startBtn.style.display = "none";
            renderPlayerList(
                data.players,
                false,
                data.currentPlayerId,
                showHandsCheckbox && showHandsCheckbox.checked,
                data
            );
        }

        if (data.type === 'game-ended') {
            alert(`ğŸ‰ ${data.winner} ã•ã‚“ãŒå‹åˆ©ã—ã¾ã—ãŸï¼`);
            disableAllButtons();
            localStorage.removeItem('dgf-playerName');
            localStorage.removeItem('dgf-roomId');
            gameStarted = false;
            startBtn.style.display = "";
        }
    });
}

if (showHandsCheckbox) {
    showHandsCheckbox.addEventListener('change', () => {
        if (latestPlayerListData) {
            renderPlayerList(
                latestPlayerListData.players,
                false,
                latestPlayerListData.currentPlayerId,
                showHandsCheckbox.checked,
                latestPlayerListData
            );
        }
    });
}

function renderHand(cards) {
    handDiv.innerHTML = '';
    cards.forEach((card) => {
        const btn = document.createElement('button');
        btn.textContent = card;
        btn.classList.add('card-btn');
        btn.disabled = true;

        btn.addEventListener('click', () => {
            socket.send(JSON.stringify({
                type: 'play-card',
                payload: {
                    roomId: currentRoomId,
                    card
                }
            }));
            btn.disabled = true;
        });
        handDiv.appendChild(btn);
    });

    const passBtn = document.createElement('button');
    passBtn.id = 'pass-button';
    passBtn.textContent = 'PASS';
    passBtn.disabled = true;
    passBtn.addEventListener('click', () => {
        const confirmed = confirm("æœ¬å½“ã«ãƒ‘ã‚¹ã—ã¾ã™ã‹ï¼Ÿ");
        if (confirmed) {
            socket.send(JSON.stringify({
                type: 'pass',
                payload: {
                    roomId: currentRoomId
                }
            }));
            passBtn.disabled = true;
        }
    });
    handDiv.appendChild(passBtn);
}

// showAllHands: trueãªã‚‰å„ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®æ‰‹æœ­å†…å®¹ã‚‚ä½µè¨˜
function renderPlayerList(players, isGameStart, turnPlayerId, showAllHands = false, playerListData = null) {
    if (!playerListDiv) return;
    playerListDiv.innerHTML = '<h3>å‚åŠ ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼</h3>';
    const ul = document.createElement('ul');
    let handsMap = {};
    if (showAllHands && playerListData && playerListData.players) {
        playerListData.players.forEach(p => {
            if (p.hand) handsMap[p.id] = p.hand;
        });
    }
    players.forEach(p => {
        let text = "";
        if ((typeof p.cardsLeft === "number") && !isGameStart) {
            text =
                p.isNPC ? `${p.name} (NPC) æ®‹${p.cardsLeft}æš` :
                (p.finished ? `${p.name}ï¼ˆä¸ŠãŒã‚Šï¼‰` : `${p.name} æ®‹${p.cardsLeft}æš`);
        } else if (isGameStart) {
            text =
                p.isNPC ? `${p.name} (NPC) æ®‹${p.cardsLeft ?? ''}æš` :
                (p.finished ? `${p.name}ï¼ˆä¸ŠãŒã‚Šï¼‰` : `${p.name} æ®‹${p.cardsLeft ?? ''}æš`);
        } else {
            text = p.isNPC ? `${p.name} (NPC)` : `${p.name}`;
        }
        if (showAllHands && handsMap && handsMap[p.id] && handsMap[p.id].length > 0) {
            text += ` [${handsMap[p.id].join(', ')}]`;
        }
        const li = document.createElement('li');
        if (turnPlayerId && p.id === turnPlayerId) {
            li.textContent = `â–·${text}`;
        } else {
            li.textContent = text;
        }
        if (myName && p.name === myName) li.style.fontWeight = "bold";
        ul.appendChild(li);
    });
    playerListDiv.appendChild(ul);
}

startBtn.addEventListener('click', () => {
    socket.send(JSON.stringify({
        type: 'start-game',
        payload: {
            roomId: currentRoomId
        }
    }));
    startBtn.disabled = true;
});

function updateField(card) {
    if (fieldDiv) {
        fieldDiv.innerHTML = `<h3>å ´ã®ã‚«ãƒ¼ãƒ‰: ${card}</h3>`;
    }
}

function enableHandButtons() {
    document.querySelectorAll('.card-btn').forEach(btn => btn.disabled = false);
    const passBtn = document.getElementById('pass-button');
    if (passBtn) passBtn.disabled = false;
}

function disableHandButtons() {
    document.querySelectorAll('.card-btn').forEach(btn => btn.disabled = true);
    const passBtn = document.getElementById('pass-button');
    if (passBtn) passBtn.disabled = true;
}

function disableAllButtons() {
    document.querySelectorAll('button').forEach(btn => {
        btn.disabled = true;
    });
}




public/index.html



<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å¤§å¯Œè±ª Online</title>
    <link rel="stylesheet" href="style.css">
    <style>
        #overlay-layer {
            display: none;
            position: fixed;
            z-index: 9999;
            left: 0; top: 0; width: 100vw; height: 100vh;
            background: rgba(255,255,255,0.8);
            align-items: center;
            justify-content: center;
        }
        #overlay-layer .overlay-content {
            background: #fff;
            border-radius: 16px;
            box-shadow: 0 4px 32px rgba(0,0,0,0.15);
            padding: 40px 30px;
            min-width: 300px;
            text-align: center;
        }
        #overlay-layer button {
            margin: 8px 16px 0 16px;
            font-size: 1.1em;
        }
        body.layer-active #join-section,
        body.layer-active #game-section {
            pointer-events: none;
            user-select: none;
            filter: blur(2px) grayscale(20%);
            opacity: 0.7;
        }
    </style>
</head>
<body>
    <h1>å¤§å¯Œè±ª Online</h1>
    <label style="display:block;text-align:left;margin-bottom:8px;">
      <input type="checkbox" id="show-hands-checkbox">
      å…¨å“¡ã®æ‰‹æœ­ã‚’è¡¨ç¤ºï¼ˆé–‹ç™ºç”¨ãƒ‡ãƒãƒƒã‚°ï¼‰
    </label>
    <section id="join-section">
        <form id="join-form">
            <label>åå‰: <input type="text" id="name" required></label><br>
            <label>ãƒ«ãƒ¼ãƒ ID: <input type="text" id="room-id" required></label><br>
            <label>æœ€å¤§äººæ•° (2ã€œ5): <input type="number" id="max-players" min="2" max="5" required></label><br>
            <button type="submit">å…¥å®¤</button>
        </form>
    </section>
    <section id="game-section" style="display: none;">
        <h2 id="player-name">ã‚ãªãŸã®æ‰‹æœ­</h2>
        <div id="hand"></div>
        <button id="pass-btn" style="display:none;">ãƒ‘ã‚¹</button>
        <button id="start-btn">ã‚²ãƒ¼ãƒ é–‹å§‹</button>
        <div id="player-list"></div>
        <div id="field"></div>
    </section>
    <!-- å¾©å¸°ãƒ»å‰Šé™¤ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ -->
    <div id="overlay-layer">
        <div class="overlay-content">
            <div id="overlay-msg"></div>
            <div id="overlay-buttons">
                <button id="overlay-enter-btn">å…¥ã‚‹</button>
                <button id="overlay-delete-btn">å‰Šé™¤</button>
            </div>
        </div>
    </div>
    <script src="client.js"></script>
</body>
</html>






style.css




body {
    font-family: "Arial", sans-serif;
    background-color: #f5f5f5;
    margin: 0;
    padding: 20px;
    text-align: center;
}

h1 {
    color: #333;
}

form {
    margin: 20px auto;
    max-width: 300px;
    display: flex;
    flex-direction: column;
    gap: 10px;
}

input,
button {
    padding: 10px;
    font-size: 16px;
}

#game-section {
    margin-top: 30px;
}

#hand {
    margin-top: 15px;
    font-size: 18px;
    color: #222;
}
.card-btn {
    margin: 2px;
    font-size: 20px;
}
#player-list ul {
    list-style: none;
    padding-left: 0;
}
#field {
    margin-top: 20px;
    font-size: 18px;
}





server/GameRoom.js




class GameRoom {
    constructor(roomId, maxPlayers, onDeleteRoom) {
        this.roomId = roomId;
        this.maxPlayers = maxPlayers;
        this.players = [];
        this.npcCount = 0;
        this.started = false;
        this.lastPlayedCard = null;
        this.lastPlayerId = null;
        this.currentTurnIndex = 0;
        this.finishedPlayerIds = new Set();
        this.passedPlayerIds = new Set();
        this.onDeleteRoom = onDeleteRoom;
    }

    addPlayer(player) {
        if (this.players.length < this.maxPlayers) {
            this.players.push(player);
            return true;
        }
        return false;
    }

    fillWithNPCs() {
        while (this.players.length < this.maxPlayers) {
            const npc = {
                id: `npc${this.npcCount++}`,
                name: `NPC${this.npcCount}`,
                isNPC: true,
                hand: [],
            };
            this.players.push(npc);
        }
    }

    replaceNPCWithHuman(humanPlayer) {
        const npcIndex = this.players.findIndex(p => p.isNPC);
        if (npcIndex !== -1) {
            humanPlayer.hand = this.players[npcIndex].hand;
            this.players[npcIndex] = humanPlayer;
            return true;
        }
        return false;
    }

    startGame() {
        this.started = true;
        this.finishedPlayerIds.clear();
        this.lastPlayedCard = null;
        this.lastPlayerId = null;
        this.currentTurnIndex = 0;
        this.passedPlayerIds = new Set();
        this.fillWithNPCs();

        const deck = this.createShuffledDeck();
        const cardsPerPlayer = Math.floor(deck.length / this.players.length);

        for (let i = 0; i < this.players.length; i++) {
            let hand = deck.slice(i * cardsPerPlayer, (i + 1) * cardsPerPlayer);
            hand = this.sortHand(hand);

            this.players[i].hand = hand;

            if (!this.players[i].isNPC && this.players[i].ws) {
                this.players[i].ws.send(JSON.stringify({
                    type: "hand",
                    cards: hand
                }));
            }
        }

        this.broadcastTurn();
        this.broadcastPlayerList();
    }

    createShuffledDeck() {
        const suits = ["â™ ", "â™¥", "â™¦", "â™£"];
        const ranks = ["3","4","5","6","7","8","9","10","J","Q","K","A","2"];
        const deck = [];
        for (let rank of ranks) {
            for (let suit of suits) {
                deck.push(`${suit}${rank}`);
            }
        }
        for (let i = deck.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [deck[i], deck[j]] = [deck[j], deck[i]];
        }
        return deck;
    }

    sortHand(hand) {
        const order = ["3","4","5","6","7","8","9","10","J","Q","K","A","2"];
        return hand.slice().sort((a, b) => {
            const ra = a.slice(1), rb = b.slice(1);
            return order.indexOf(ra) - order.indexOf(rb);
        });
    }

    getCardRank(card) {
        return card.slice(1);
    }

    getCardStrength(card) {
        const order = ["3","4","5","6","7","8","9","10","J","Q","K","A","2"];
        return order.indexOf(this.getCardRank(card));
    }

    canPlayCardOnField(fieldCard, playCard) {
        if (!fieldCard) return true;
        return this.getCardStrength(playCard) > this.getCardStrength(fieldCard);
    }

    hasPlayableCard(player, lastCard) {
        if (!player.hand || player.hand.length === 0) return false;
        return player.hand.some(card => this.canPlayCardOnField(lastCard, card));
    }

    isAllOtherPlayersPassedOrBlocked(lastCard, lastPlayerId) {
        if (!lastCard) return false;
        const aliveOthers = this.players.filter(
            p => !this.finishedPlayerIds.has(p.id) && p.id !== lastPlayerId
        );
        for (const p of aliveOthers) {
            if (!this.passedPlayerIds.has(p.id) && this.hasPlayableCard(p, lastCard)) {
                return false;
            }
        }
        return aliveOthers.length > 0;
    }

    handlePlayerAction(playerId, type, payload) {
        const player = this.players.find(p => p.id === playerId);

        // ç¾åœ¨ã®æ‰‹ç•ªãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼æ±ºå®š
        let skipCount = 0;
        let currentPlayer;
        while (skipCount < this.players.length) {
            currentPlayer = this.players[this.currentTurnIndex];
            if (!this.finishedPlayerIds.has(currentPlayer.id)) break;
            this.currentTurnIndex = (this.currentTurnIndex + 1) % this.players.length;
            skipCount++;
        }

        if (!player || !player.hand || player.id !== currentPlayer.id) return;

        if (type === "play-card") {
            const cardIndex = player.hand.indexOf(payload.card);
            if (cardIndex !== -1) {
                if (!this.canPlayCardOnField(this.lastPlayedCard, payload.card)) {
                    if (!player.isNPC && player.ws) {
                        player.ws.send(JSON.stringify({
                            type: "error",
                            message: "ãã®ã‚«ãƒ¼ãƒ‰ã¯å‡ºã›ã¾ã›ã‚“ï¼ˆå ´ã®ã‚«ãƒ¼ãƒ‰ã‚ˆã‚Šå¼·ã„ã‚«ãƒ¼ãƒ‰ã®ã¿å‡ºã›ã¾ã™ï¼‰"
                        }));
                    }
                    this.broadcastTurn();
                    this.broadcastPlayerList();
                    return;
                }

                const [card] = player.hand.splice(cardIndex, 1);
                this.lastPlayedCard = card;
                this.lastPlayerId = playerId;
                this.passedPlayerIds.clear();

                if (!player.isNPC && player.ws) {
                    player.ws.send(JSON.stringify({
                        type: "hand",
                        cards: this.sortHand(player.hand)
                    }));
                }

                this.players.forEach(p => {
                    if (p.ws) {
                        p.ws.send(JSON.stringify({
                            type: "field-card",
                            card
                        }));
                    }
                });

                if (player.hand.length === 0) {
                    this.finishedPlayerIds.add(player.id);
                    this.broadcastWinner(player.name);
                    this.broadcastPlayerList();
                    return;
                }

                if (this.isAllOtherPlayersPassedOrBlocked(this.lastPlayedCard, this.lastPlayerId)) {
                    this.lastPlayedCard = null;
                    this.passedPlayerIds.clear();

                    this.players.forEach(p => {
                        if (p.ws) {
                            p.ws.send(JSON.stringify({
                                type: "field-card",
                                card: "ï¼ˆãƒªã‚»ãƒƒãƒˆï¼‰"
                            }));
                        }
                    });

                    const idx = this.players.findIndex(p => p.id === this.lastPlayerId);
                    this.currentTurnIndex = idx !== -1 ? idx : 0;
                    this.broadcastTurn();
                    this.broadcastPlayerList();

                    const currentPlayer = this.players[this.currentTurnIndex];
                    if (currentPlayer.isNPC && currentPlayer.hand && currentPlayer.hand.length > 0) {
                        setTimeout(() => {
                            if (this.finishedPlayerIds.has(currentPlayer.id)) return;
                            const playable = currentPlayer.hand.find(card => this.canPlayCardOnField(this.lastPlayedCard, card));
                            if (playable) {
                                this.handlePlayerAction(currentPlayer.id, "play-card", { card: playable });
                            } else {
                                this.handlePlayerAction(currentPlayer.id, "pass", {});
                            }
                        }, 500);
                    }
                    return;
                }

                this.advanceTurn();
                return;
            }
        } else if (type === "pass") {
            this.passedPlayerIds.add(playerId);

            if (player.ws) {
                player.ws.send(JSON.stringify({
                    type: "pass-ack"
                }));
            }

            if (
                this.isAllOtherPlayersPassedOrBlocked(this.lastPlayedCard, this.lastPlayerId)
            ) {
                this.lastPlayedCard = null;
                this.passedPlayerIds.clear();

                this.players.forEach(p => {
                    if (p.ws) {
                        p.ws.send(JSON.stringify({
                            type: "field-card",
                            card: "ï¼ˆãƒªã‚»ãƒƒãƒˆï¼‰"
                        }));
                    }
                });

                const idx = this.players.findIndex(p => p.id === this.lastPlayerId);
                this.currentTurnIndex = idx !== -1 ? idx : 0;
                this.broadcastTurn();
                this.broadcastPlayerList();

                const currentPlayer = this.players[this.currentTurnIndex];
                if (currentPlayer.isNPC && currentPlayer.hand && currentPlayer.hand.length > 0) {
                    setTimeout(() => {
                        if (this.finishedPlayerIds.has(currentPlayer.id)) return;
                        const playable = currentPlayer.hand.find(card => this.canPlayCardOnField(this.lastPlayedCard, card));
                        if (playable) {
                            this.handlePlayerAction(currentPlayer.id, "play-card", { card: playable });
                        } else {
                            this.handlePlayerAction(currentPlayer.id, "pass", {});
                        }
                    }, 500);
                }
                return;
            } else {
                this.advanceTurn();
            }
            return;
        }
    }

    advanceTurn() {
        let attempts = 0;
        let found = false;
        while (attempts < this.players.length) {
            this.currentTurnIndex = (this.currentTurnIndex + 1) % this.players.length;
            const nextPlayer = this.players[this.currentTurnIndex];
            if (!this.finishedPlayerIds.has(nextPlayer.id)) {
                found = true;
                break;
            }
            attempts++;
        }
        if (!found) return;

        this.broadcastTurn();
        this.broadcastPlayerList();

        const nextPlayer = this.players[this.currentTurnIndex];
        if (nextPlayer.isNPC && nextPlayer.hand && nextPlayer.hand.length > 0) {
            setTimeout(() => {
                if (this.finishedPlayerIds.has(nextPlayer.id)) return;
                const playable = nextPlayer.hand.find(card => this.canPlayCardOnField(this.lastPlayedCard, card));
                if (playable) {
                    this.handlePlayerAction(nextPlayer.id, "play-card", { card: playable });
                } else {
                    this.handlePlayerAction(nextPlayer.id, "pass", {});
                }
            }, 500);
        }
    }

    broadcastTurn() {
        const currentPlayer = this.players[this.currentTurnIndex];
        this.players.forEach(p => {
            if (p.ws) {
                p.ws.send(JSON.stringify({
                    type: "your-turn",
                    isYourTurn: p.id === currentPlayer.id,
                    currentPlayerId: currentPlayer.id
                }));
            }
        });
    }

    broadcastWinner(winnerName) {
        this.players.forEach(p => {
            if (p.ws) {
                p.ws.send(JSON.stringify({
                    type: "game-ended",
                    winner: winnerName
                }));
            }
        });
        this.started = false;
        if (this.onDeleteRoom) {
            setTimeout(() => {
                this.onDeleteRoom(this.roomId);
            }, 5000);
        }
    }

    // æ‰‹æœ­æƒ…å ±ã‚’å„playerã«å«ã‚ã‚‹
    broadcastPlayerList() {
        const playerSummaries = this.players.map(p => ({
            id: p.id,
            name: p.name,
            isNPC: p.isNPC,
            cardsLeft: p.hand && Array.isArray(p.hand) ? p.hand.length : undefined,
            hand: p.hand || [], // â†ã“ã“ã§æ‰‹æœ­ã‚’å«ã‚ã‚‹ï¼ˆã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆãƒ‡ãƒãƒƒã‚°ç”¨ï¼‰
            finished: this.finishedPlayerIds.has(p.id)
        }));
        const currentPlayer = this.players[this.currentTurnIndex];
        this.players.forEach(p => {
            if (p.ws) {
                p.ws.send(JSON.stringify({
                    type: "player-list",
                    players: playerSummaries,
                    currentPlayerId: currentPlayer.id
                }));
            }
        });
    }

    isFull() {
        return this.players.length >= this.maxPlayers;
    }

    removePlayer(playerId) {
        this.players = this.players.filter(p => p.id !== playerId);
    }
}

module.exports = GameRoom;





server/server.js





const express = require('express');
const http = require('http');
const WebSocket = require('ws');
const path = require('path');
const GameRoom = require('./GameRoom');

const app = express();
const server = http.createServer(app);
const wss = new WebSocket.Server({ server });

app.use(express.static(path.join(__dirname, '../public')));

const rooms = new Map();

// ãƒ«ãƒ¼ãƒ å‰Šé™¤é–¢æ•°
function deleteRoom(roomId) {
    rooms.delete(roomId);
}

wss.on('connection', (ws) => {
    ws.on('message', (message) => {
        let data;
        try {
            data = JSON.parse(message);
        } catch (err) {
            console.error('Invalid JSON:', message);
            return;
        }

        const { type, payload } = data;

        if (type === 'create-room') {
            const { roomId, maxPlayers, playerName } = payload;
            if (rooms.has(roomId)) {
                ws.send(JSON.stringify({ type: 'error', message: 'ãã®éƒ¨å±‹IDã¯æ—¢ã«å­˜åœ¨ã—ã¾ã™ã€‚' }));
                return;
            }

            const room = new GameRoom(roomId, maxPlayers, deleteRoom);
            const hostPlayer = { id: generateId(), name: playerName, isNPC: false, ws };
            room.addPlayer(hostPlayer);
            rooms.set(roomId, room);

            ws.roomId = roomId;
            ws.playerId = hostPlayer.id;

            ws.send(JSON.stringify({ type: 'room-created', roomId }));
        }

        else if (type === 'join-room') {
            const { roomId, playerName } = payload;
            const room = rooms.get(roomId);

            if (!room) {
                ws.send(JSON.stringify({ type: 'error', message: 'ãã®éƒ¨å±‹ã¯å­˜åœ¨ã—ã¾ã›ã‚“ã€‚' }));
                return;
            }

            // --- ã“ã“ã‹ã‚‰å¾©å¸°å‡¦ç† ---
            const player = room.players.find(p => p.name === playerName);
            if (player) {
                // æ—¢å­˜ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®wsã‚’æ›¸ãæ›ãˆã¦å¾©å¸°
                player.ws = ws;
                ws.roomId = roomId;
                ws.playerId = player.id;
                ws.send(JSON.stringify({ type: 'joined-room', roomId }));
                room.broadcastPlayerList();
                // å¾©å¸°ã—ãŸäººã®æ‰‹æœ­ãƒ»ã‚¿ãƒ¼ãƒ³ç­‰ã‚‚å†é€šçŸ¥
                if (player.hand) {
                    ws.send(JSON.stringify({ type: 'hand', cards: player.hand }));
                }
                if (room.players[room.currentTurnIndex].id === player.id) {
                    ws.send(JSON.stringify({
                        type: "your-turn",
                        isYourTurn: true,
                        currentPlayerId: player.id
                    }));
                }
                return;
            }
            // --- å¾©å¸°å‡¦ç†ã“ã“ã¾ã§ ---

            const newPlayer = { id: generateId(), name: playerName, isNPC: false, ws };
            const success = room.replaceNPCWithHuman(newPlayer) || room.addPlayer(newPlayer);
            if (!success) {
                ws.send(JSON.stringify({ type: 'error', message: 'éƒ¨å±‹ãŒæº€å“¡ã§ã™ã€‚' }));
                return;
            }

            ws.roomId = roomId;
            ws.playerId = newPlayer.id;

            ws.send(JSON.stringify({ type: 'joined-room', roomId }));
            room.broadcastPlayerList();
        }

        else if (type === 'start-game') {
            const room = rooms.get(ws.roomId);
            if (!room) return;

            room.startGame();
            room.broadcastPlayerList();

            room.players.forEach(p => {
                if (p.ws) {
                    p.ws.send(JSON.stringify({
                        type: 'game-started',
                        players: room.players.map(p2 => ({
                            id: p2.id,
                            name: p2.name,
                            isNPC: p2.isNPC
                        }))
                    }));
                }
            });
        }

        else if (type === 'play-card' || type === 'pass') {
            const room = rooms.get(ws.roomId);
            if (!room) return;

            payload.playerId = ws.playerId;
            room.handlePlayerAction(ws.playerId, type, payload);
        }
    });

    ws.on('close', () => {
        const room = rooms.get(ws.roomId);
        if (room) {
            const player = room.players.find(p => p.id === ws.playerId);
            if (player) {
                player.ws = null;
            }
            // éƒ¨å±‹ã¯æ±ºç€(game-ended)ã¾ã§çµ¶å¯¾æ¶ˆã•ãªã„ï¼
        }
    });
});

function generateId() {
    return Math.random().toString(36).substr(2, 9);
}

server.listen(3000, () => {
    console.log('ã‚µãƒ¼ãƒãƒ¼èµ·å‹• http://localhost:3000');
});
