現在の実装状況と完成度（2025年7月時点まとめ）
✅実装済み機能（コードベース最新）
サーバー/クライアント通信：Node.js + Express + WebSocketでリアルタイム通信

クライアントUI：HTML/CSS/JS（手札表示・選択・カード出し・パス・結果表示）

基本ルール：手札出し／パス／8切り／革命／Jバック／階段

NPC自動補充&ロジック：足りない場合自動参加し、単純なロジックで自動プレイ

勝敗判定／順位付け：大富豪〜大貧民まで順位付けし結果表示

再接続対応：同名で入室すると手札や状態を復帰

WebSocketリアルタイム同期：全クライアントへ状態即時反映

UML設計（クラス図・シーケンス・アクティビティ・ユースケース）との一貫性

🐞現時点の致命的バグ・直すべき点（優先度つき）
優先度	内容	状況・備考
🔴高	自分の手札が0枚でも番が回ってくる	0枚時に上がり処理が不完全。ターン処理がループ。
🔴高	階段でJOKER出し時、変身先（4/8）選択UIが無い	プレイヤーがJOKERの出し方を明示できず、ロジック不一致。
🟠中	階段で革命が発動しない	4枚階段等で革命が起こるべきだが、同ランクペアのみになっている。
🟠中	革命時にJバックの順が逆にならないバグ	状態フラグの扱いに不整合。
🟢低	8切り・スペ3返し周辺の流し処理	軽微な表示・ロジックの違和感。

🔜追加・改修すべき主な機能リスト
1.ターン自動スキップ＆上がり抜け管理

*手札0枚プレイヤーは即「finished」とし、ターンをスキップ

*全員上がった場合のループ防止（isGameOver/getNextAliveの強化）

2.階段＋JOKER UI/ロジック

*プレイヤーがJOKERを出すとき、どのカードとして扱うかUI選択→サーバへ伝達

*サーバはJOKER変身先を明示的に受け取り、役判定・ルール判定に利用

3.階段での革命判定

*同ランク4枚だけでなく、「4枚以上連続階段」でも革命発動へロジック強化

*クラス図・シーケンス図も修正

4.Jバック＋革命状態の処理分岐

*Jバック中は順序が「一時的に」元に戻る、その後再び革命順へ戻るように

*状態遷移の見直しとテスト

5.スペ3返し／8切りなどの特殊流しの明示化

*UI表示も「場流し」「革命返し」など明確なログやアニメーションを追加

6.JOKER変身UIの設計

*クライアント側：階段選択時にJOKERをクリック→変身先候補をモーダル表示し選択→その内容でplay送信

🔶 今後の機能ごとの設計方針
ローカルルールON/OFF

ルーム作成時にチェックボックス式で任意ルール選択可能とする

サーバ側はroom.settings（boolean値で持つ）で分岐

観戦モード

途中入室者はrole: 'spectator'で参加

プレイボタン・手札UI非表示、チャットのみ利用可能

サーバ側で観戦ユーザには状態のみ送信

チャット

ルーム全体チャット（フォーム＋履歴欄）

サーバ: type: 'chat' メッセージ受信で全員に配信

縛り実装

場に出されたスートを記憶し、以降ターンで縛り条件を追加

room.lastPlayedSuit 追加し、handlePlay時に判定

UI改善

現在ターン/残り手札枚数/パス回数等を強調

NPC・観戦者の区別も分かるようラベル追加

その他（通信・管理）

ロビー：rooms[]一覧API/画面

ターンタイマー：your-turn時setTimeoutで自動パス

【設計書】全体粒度
● ターン管理と上がり抜け
GameRoom.jsのgetNextAliveメソッドを全て「未上がり（finished=false）」のみ選ぶようにループ強化

上がった瞬間ターンを自動で飛ばす

handlePlay/handlePass等、ターン終了後必ず「生きてる」プレイヤーへ遷移

isGameOver()は残り1人以下ですぐ終了

● 階段+JOKER UI（クライアント）
playSelected時、JOKER含む階段が選択されていたら

変身先（rank, suit）候補を自動抽出しモーダルで表示

プレイヤーが明示選択→cards配列にjokerTransform:{suit, rank}を加えてサーバ送信

サーバもJOKERの変身先を必ず参照し役判定

階段革命発動はisValidStairs内で「4枚以上の階段」で革命ON判定を追加

● サーバのJOKER対応
handlePlayでjokerTransform情報を受け取り、それで階段や8切り/7渡し/革命の判定も一致するように

変身先が8/7なら両ルール発動

● Jバック＋革命競合ロジック
革命時にJバック発動→1ターンだけ通常順→次ターンで再び革命

状態フラグjBackActiveとrevolutionの判定優先順位・消去タイミングを明確化

シーケンス図も一時的な状態遷移が見えるよう修正

● 階段での革命判定
階段出し時（isMoveStairs=trueかつlength>=4）でも革命フラグONに

📝致命的バグの根本解決アプローチ（提案）
1. ターンループ＆上がりバグの解決策

getNextAlive()・ターン管理強化

毎ターン終了時、finishedフラグがtrueならスキップするwhileループ徹底

handlePlay/handlePass/全ルートでターン遷移後に即「次の生きてるプレイヤー」へジャンプ

isGameOverは「finished=false」の人数判定で分岐

勝ち抜け人数が増えた瞬間、順位とfinishedを必ず更新



2. JOKER変身UI/階段JOKERの実装
A案（標準的）
クライアント

playSelectedで階段＋JOKER検出時、サーバにJOKER変身先も伝える

JOKER変身先を指定しなければプレイ不可に

サーバ

handlePlayでJOKER変身先が必須になる場合はそれを参照して判定


3. 階段での革命ロジック
A案（最も一般的）
階段役判定isMoveStairs内で、4枚以上階段＝革命の判定ロジック追加

革命中に再び4枚階段で「革命返し」



【全体設計】改修粒度・今後の構成指針
サーバ/クライアント双方で状態遷移を統一

各ルールごとの優先順位を表・コードコメントで明示

階段/JOKER対応はUI/ロジック両面で設計

設計書はUML粒度で随時追記（競合ルール、状態遷移図、シーケンス詳細）

【質問・確認したい点】
1.JOKER変身UIの仕様：

クライアントで「変身先カード」をユーザーが選択する方式でOKか？
（自動判定 or ユーザー選択かを決めてください）
→自分で決める
2.階段革命のトリガー：

4枚以上階段なら革命、という仕様で良いか？
例）5,6,7,8 などの階段で革命発動
→4段以上で革命
3.順位付け＆上がり抜け仕様：

勝ち抜け順に大富豪〜大貧民を自動付与、最後まで続行でOKか？
→そう、例:5人対戦ならそれに加えて大富豪、富豪、平民、貧民、大貧民
それぞれに+2,+1,0,-1,-2点を付与(4人対戦ならここから平民が消える.3人なら富豪,平民,貧民.2人対戦なら富豪,貧民)
最後が何かは何ゲーム制にするのかをルーム作成時点で決められるようにする
4.Jバック＋革命競合は

「Jバック時だけ一時的に通常順、次ターンで革命順復帰」でOKか
→革命時にjバック発動の際は、一時的に通常順です
しかしこれはもう治っていると思います






🟡 今後追加すべき残り機能（設計書／クラス図の観点から）
機能	内容	状態	備考
🔁 ゲームリセット機能	勝者決定後、2ゲーム目を開始できる仕組み	未実装	GameRoom を再利用できるようにする必要あり
🧠 NPCの簡易ロジック	NPCが自動でカードを出す or パスする	未実装	現在NPCは何も行動しない
♻️ 再接続処理	接続が切れたプレイヤーが復帰できる	未実装	WebSocket切断後の処理拡張が必要
📝 観戦モード	観戦のみのプレイヤー（isSpectator）	任意	UMLにあればだが今は優先度低
🧩 ローカルルールの導入	8切り・革命など大富豪ルール	任意	ステップアップ項目（今はシンプル仕様）
🧑‍🤝‍🧑 UIの改善	プレイヤーのターン表示・残り手札枚数など	一部済	改善余地あり（より視覚的に）
🧪 テスト導入	単体テスト・シナリオテスト	未着手	本格開発では必要になる工程


🔁 ゲーム再スタート機能
　→ ゲーム終了後に新しいゲームを同じルームで始められるようにする。
　→ resetGame() などを GameRoom に追加、client側に「再スタート」ボタン実装。

前回gptのメモ以下(これは間違っている部分もある可能性があることに留意してください)
✅ 構築環境（ローカル開発環境）
項目	内容
OS	Windows（Code Page: 65001 / UTF-8）
実行環境	Node.js (server.js によるWebSocketサーバー)
使用パッケージ	express, ws
ディレクトリ構成	C:\dgf-online\ 配下に以下が存在：
├─ server/ → server.js, GameRoom.js
└─ public/ → client.js, index.html など
起動方法	node server/server.js にてローカルサーバー起動
ポート	http://localhost:3000 で接続確認済み
クライアント通信	WebSocket（ws://localhost:3000）でリアルタイム通信
実行ログ	サーバー起動 http://localhost:3000 確認済み
ブラウザ動作	クライアント画面表示・ゲーム開始可能（通信は動作）

📌 現状の進捗と課題
ステータス	内容
✅ ゲームルーム作成	主催者が部屋を作成し、最大人数設定可能
✅ プレイヤー参加	他ユーザーが参加。人数不足時は NPC 自動補充
✅ ゲーム開始処理	「スタートボタン」押下で全プレイヤーに手札配布
✅ 手札表示	クライアント側にカードがボタン形式で表示される
✅ 勝利判定	プレイヤーの手札が空になったら勝利と判定し、game-ended を送信
⚠️ 未確認または不安定	以下の挙動がまだ検証・調整中：
・ターン終了後、次のプレイヤーの your-turn が正しく届かない場合がある
・他プレイヤーにカード出しが反映されないことがある
・NPCの自動ターン処理は未実装（現状では待ちのまま）

🎯 次に実装・確認すべき項目（目安）
 出したカードが他プレイヤーの画面にも正しく反映されるか確認

 ターンが循環するように your-turn 通知が連携しているかテスト

 NPCの自動カード出し（AIロジック or ランダム）実装（必要に応じて）

 UIリセット／2ゲーム目以降の処理確認

🧭 引き継ぎのための一言メモ（テンプレ）
このプロジェクトは Node.js + WebSocket を用いた「大富豪オンラインゲーム」です。
現時点でゲームスタート〜勝利判定までは一通り通っており、残る課題はターン同期と他クライアントへのリアルタイム反映です。
NPCのロジックや再試合機能は後回しで、まずは1ゲームがスムーズに進行することを優先しています。





以下コード
public/client.js


// =================================
//  client.js  ― 七渡し完全UI・バグ防止対応 + 冗長性
// =================================
let ws, playerName, roomId;

// --------- DOM ユーティリティ ---------
const $ = id => document.getElementById(id);

// --------- WebSocket 接続 ---------
function connect() {
  const proto = location.protocol === 'https:' ? 'wss' : 'ws';
  ws = new WebSocket(`${proto}://${location.host}`);
  ws.onopen = () => ws.send(JSON.stringify({ type: 'join', room: roomId, name: playerName }));
  ws.onmessage = e => handle(JSON.parse(e.data));
  ws.onclose = () => setTimeout(connect, 1000);
}

// --------- 初期化 ---------
window.onload = () => {
  const p = new URLSearchParams(location.search);
  playerName = p.get('name'); roomId = p.get('room');
  if (!playerName || !roomId) { location = 'index.html'; return; }
  $('roomLabel').textContent = `ルーム: ${roomId}`;
  connect();

  $('startBtn').onclick = () => ws.send(JSON.stringify({ type: 'start' }));
  $('resetBtn').onclick = () => ws.send(JSON.stringify({ type: 'reset' }));
  $('quitBtn').onclick = () => location = 'index.html';
  $('playBtn').onclick = playSelected;
  $('passBtn').onclick = () => ws.send(JSON.stringify({ type: 'pass' }));

  // 🟦 七渡しUI
  if ($('sevenSection')) {
    $('sevenGiveBtn').onclick = sendSevenCard;
    $('sevenSection').style.display = 'none';
  }
};

function playSelected() {
  const sel = [...document.querySelectorAll('.card.selected')];
  if (sel.length === 0) return;
  const data = sel.map(b => ({ suit: b.dataset.suit, rank: b.dataset.rank }));
  ws.send(JSON.stringify({ type: 'play', cards: data }));
  sel.forEach(b => b.classList.remove('selected'));
}

// 🟦 七渡し: 必要な枚数だけ選択し一括送信
function sendSevenCard() {
  const sel = [...document.querySelectorAll('.card.selected')];
  const n = parseInt($('sevenSection').dataset.needcount, 10) || 1;
  if (sel.length !== n) return;
  const cards = sel.map(b => ({ suit: b.dataset.suit, rank: b.dataset.rank }));
  ws.send(JSON.stringify({ type: 'seven-give', cards }));
  sel.forEach(b => b.classList.remove('selected'));
  $('sevenSection').style.display = 'none';
}

// --------- 受信メッセージで画面更新 ---------
function handle(state) {
  // ===== ゲーム終了画面 =====
  if (state.type === 'final') {
    $('playersList').innerHTML = '';
    $('fieldCards').textContent = '';
    $('handSection').style.display = 'none';
    $('sevenSection').style.display = 'none';
    $('statusMsg').textContent = 'ゲーム終了';
    const res = $('result'); res.innerHTML = '<h3>結果</h3>';
    state.ranking.forEach(r => {
      const div = document.createElement('div');
      div.textContent = `${r.title}: ${r.name}さん`;
      res.appendChild(div);
    });
    $('resetBtn').style.display = (state.players[0].name === playerName) ? 'inline-block' : 'none';
    $('quitBtn').style.display = (state.players[0].name === playerName) ? 'inline-block' : 'none';
    $('startBtn').style.display = 'none';
    return;
  }

  if (!state.started) {
    $('startBtn').style.display =
      state.players.length >= 1 && state.players[0].name === playerName ? 'inline-block' : 'none';
    $('resetBtn').style.display = 'none'; $('quitBtn').style.display = 'none';

    $('playersList').innerHTML = state.players.map(p =>
      `<div>${p.name}さん（入室中）</div>`).join('');
    $('fieldCards').textContent = '（ゲーム待機中）';
    $('handSection').style.display = 'none';
    $('sevenSection').style.display = 'none';
    $('result').innerHTML = ''; $('statusMsg').textContent = '';
    return;
  }

  // 🟦 七渡しUI表示（必要な枚数分だけカードを選ばせる）
  if (state.waitingForSevenCard && state.waitingForSevenCardPlayer === playerName) {
    $('sevenSection').style.display = 'block';
    $('sevenSection').dataset.needcount = state.needSevenCount || 1;
    $('sevenSection').querySelector('.seven-desc').textContent =
      `7渡し: 手札から${state.needSevenCount || 1}枚選んで「渡す」を押してください`;
  } else {
    if ($('sevenSection')) $('sevenSection').style.display = 'none';
  }

  $('startBtn').style.display = 'none';
  $('resetBtn').style.display = 'none';
  $('quitBtn').style.display = 'none';

  $('playersList').innerHTML = state.players.map(p => {
    const cur = p.name === state.currentTurn ? ' style="background:#ffef99"' : '';
    const me = p.name === playerName ? ' style="font-weight:bold"' : '';
    const sty = cur || me;
    const txt = p.finished ? `${p.name}さん - 上がり`
      : `${p.name}さん - ${p.cardsCount}枚`;
    return `<div${sty}>${txt}</div>`;
  }).join('');

  $('fieldCards').textContent =
    state.field.cards.length ? `場: [${state.field.cards.join(', ')}]` : '場: （なし）';

  const hc = $('handCards'); hc.innerHTML = '';
  state.yourHand.forEach(s => {
    const b = document.createElement('button'); b.className = 'card'; b.textContent = s;
    if (s === 'Joker') { b.dataset.suit = 'J'; b.dataset.rank = '16'; }
    else { b.dataset.suit = s[0]; b.dataset.rank = s.slice(1); }
    b.onclick = () => b.classList.toggle('selected');
    hc.appendChild(b);
  });
  $('handSection').style.display = 'block';

  const myTurn = state.currentTurn === playerName;
  $('playBtn').disabled = !myTurn || (state.waitingForSevenCard && state.waitingForSevenCardPlayer === playerName);
  $('passBtn').disabled = !myTurn || state.field.cards.length === 0 || (state.waitingForSevenCard && state.waitingForSevenCardPlayer === playerName);

  if (state.waitingForSevenCard && state.waitingForSevenCardPlayer === playerName) {
    $('playBtn').disabled = true;
    $('passBtn').disabled = true;
  }

  $('statusMsg').textContent = state.revolution ? '革命発生中!' : '';
  $('lastAction').textContent = state.lastMove ?
    (state.lastMove.move === 'pass'
      ? `${state.lastMove.player}さんがパスしました`
      : `${state.lastMove.player}さんが ${state.lastMove.cards.join(', ')} を出しました`
      + (state.lastMove.special ? ` (${state.lastMove.special})` : '')) : '';
}










public/game.html









<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8" />
    <title>大富豪オンライン - ゲーム</title>
    <link rel="stylesheet" href="style.css" />
</head>

<body>
    <h1>大富豪オンライン</h1>
    <div id="roomLabel"></div>
    <div id="playersList" class="players-list"></div>
    <div id="fieldCards" class="field"></div>
    <div id="statusMsg" class="status-msg"></div>
    <div id="lastAction" class="last-action"></div>

    <div id="handSection">
        <h2 id="handTitle"></h2>
        <div id="handCards" class="hand-cards"></div>
        <div class="controls">
            <button id="playBtn">出す</button>
            <button id="passBtn">パス</button>
        </div>
    </div>
    <!-- 七渡しUIセクション -->
    <div id="sevenSection" style="display:none;">
        <div class="seven-desc" style="margin:10px 0; color:#c00; font-weight:bold;">
            7渡し: 手札から1枚選んで「渡す」を押してください
        </div>
        <button id="sevenGiveBtn">渡す</button>
    </div>
    <div id="result" class="result"></div>
    <button id="startBtn" class="start-btn">ゲーム開始</button>
    <button id="resetBtn" class="reset-btn">再戦</button>
    <button id="quitBtn" class="reset-btn">ルーム解散</button>
    <script src="client.js"></script>
</body>

</html>














public/index.html











<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8" />
    <title>大富豪オンライン - 入室</title>
    <link rel="stylesheet" href="style.css" />
</head>

<body>
    <h1>大富豪オンライン ゲーム</h1>
    <div class="form-container">
        <form id="joinForm" action="game.html" method="GET">
            <label>プレイヤー名: <input type="text" name="name" required /></label><br />
            <label>ルームID: <input type="text" name="room" required /></label><br />
            <button type="submit">入室</button>
        </form>
    </div>
</body>

</html>














style.css














body {
    font-family: sans-serif;
    margin: 20px;
}

h1 {
    margin-bottom: 10px;
}

.form-container {
    margin-top: 20px;
}

.players-list {
    margin: 10px 0;
    padding: 10px;
    border: 1px solid #333;
    max-width: 300px;
}

.players-list .current-turn {
    background-color: #ffef99;
}

.field {
    font-weight: bold;
    margin: 10px 0;
}

.status-msg {
    margin: 5px 0;
    font-weight: bold;
}

.last-action {
    margin: 5px 0;
    font-style: italic;
}

#handSection {
    margin: 15px 0;
}

.hand-cards {
    margin: 5px 0;
}

.hand-cards .card {
    margin: 2px;
    padding: 5px 8px;
    cursor: pointer;
}

.hand-cards .card.selected {
    background-color: #aed;
}

.controls {
    margin: 5px 0;
}

.controls button {
    margin-right: 10px;
}

.start-btn,
.reset-btn {
    display: none;
    /* 必要な時に表示 */
    margin-top: 15px;
    padding: 5px 10px;
}

.result {
    margin-top: 15px;
    padding: 10px;
    border: 1px solid #555;
    max-width: 300px;
    background-color: #f9f9f9;
}














server/GameRoom.js














// ====================================
//  GameRoom.js  ― 七渡し・革命・Jバックバグ完全修正（冗長・省略ゼロ）
// ====================================

class Card {
    constructor(suit, rank) {
        this.suit = suit;
        this.rank = rank;
        this.isJoker = suit === 'J';
    }
    toString() {
        return this.isJoker ? 'Joker' : this.suit + Card.rankToLabel(this.rank);
    }
    static rankToLabel(r) {
        return { 11: 'J', 12: 'Q', 13: 'K', 14: 'A', 15: '2' }[r] || String(r);
    }
}

class Deck {
    constructor(useJoker = true) {
        this.cards = [];
        const suits = ['♣', '♦', '♥', '♠'];
        const ranks = [3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15];
        for (const s of suits) for (const r of ranks) this.cards.push(new Card(s, r));
        if (useJoker) this.cards.push(new Card('J', 16));
    }
    shuffle() {
        for (let i = this.cards.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [this.cards[i], this.cards[j]] = [this.cards[j], this.cards[i]];
        }
    }
}

class Player {
    constructor(name, conn = null, isNPC = false) {
        this.name = name;
        this.conn = conn;
        this.connected = !!conn;
        this.isNPC = isNPC;
        this.hand = [];
        this.finished = false;
        this.rankTitle = '';
    }
}

class GameRoom {
    constructor(roomId) {
        this.roomId = roomId;
        this.players = [];
        this.started = false;
        this.currentTurn = 0;
        this.jBackActive = false;
        this.lastPlayedCards = [];
        this.lastPlayedRank = null;
        this.lastPlayedCount = 0;
        this.lastPlayerIndex = null;
        this.passCount = 0;
        this.revolution = false;
        this.lastChampion = null;
        this.lastMoveInfo = null;
        this._deleteTimer = null;
        this.spade3BackPending = false;
        this.lastPlayWasStairs = false;
        this.waitingForSevenCard = false;
        this.waitingForSevenCardPlayer = null;
        this.needSevenCount = 1;
    }

    getPlayer(name) { return this.players.find(p => p.name === name); }

    addPlayer(name, conn) {
        const exist = this.getPlayer(name);
        if (exist) {
            if (exist.connected) return { ok: false, error: '同名プレイヤーが既に接続中です。' };
            exist.conn = conn; exist.connected = true; exist.isNPC = false;
            return { ok: true, reconnect: true };
        }
        this.players.push(new Player(name, conn, false));
        return { ok: true, reconnect: false };
    }

    fillNPCPlayers() {
        while (this.players.length < 4) {
            const npcName = `NPC${this.players.length}`;
            if (!this.getPlayer(npcName)) this.players.push(new Player(npcName, null, true));
        }
    }

    startGame() {
        this.started = true;
        this.revolution = false;
        this.lastPlayedCards = []; this.lastPlayedRank = null; this.lastPlayedCount = 0;
        this.lastPlayerIndex = null; this.passCount = 0; this.lastMoveInfo = null;
        this.jBackActive = false;
        this.spade3BackPending = false;
        this.lastPlayWasStairs = false;
        this.waitingForSevenCard = false;
        this.waitingForSevenCardPlayer = null;
        this.needSevenCount = 1;

        this.players.forEach(p => { p.hand = []; p.finished = false; p.rankTitle = ''; });
        this.fillNPCPlayers();

        const deck = new Deck(true); deck.shuffle();
        let idx = 0; for (const c of deck.cards) { this.players[idx].hand.push(c); idx = (idx + 1) % this.players.length; }
        this.players.forEach(p => p.hand.sort((a, b) => a.rank - b.rank));
        this.currentTurn = 0;
        this.broadcastState();
        this.checkAndHandleNPC();
    }

    getNextAlive(idx) {
        const n = this.players.length;
        let i = idx;
        do { i = (i + 1) % n; } while (this.players[i].finished);
        return i;
    }

    rankValue(card) { return card.isJoker ? 16 : card.rank; }

    isValidStairs(cards) {
        if (cards.length < 3) return false;
        const suit = cards[0].suit;
        if (!cards.every(c => c.suit === suit && !c.isJoker)) return false;
        const sorted = [...cards].sort((a, b) => a.rank - b.rank);
        for (let i = 1; i < sorted.length; i++) {
            if (sorted[i].rank !== sorted[i - 1].rank + 1) return false;
        }
        return true;
    }

    prevIsStairs() {
        return (this.lastPlayedCards.length >= 3 && this.isValidStairs(this.lastPlayedCards));
    }

    isMoveStairs(cards) {
        return (cards.length >= 3 && this.isValidStairs(cards));
    }

    isRevJBack() {
        return this.revolution && this.jBackActive;
    }

    isJBackOK(cards) {
        if (this.isRevJBack()) {
            return cards.every(c => (!c.isJoker && c.rank >= 12) || c.isJoker);
        } else {
            return cards.every(c => !c.isJoker && c.rank <= 11);
        }
    }

    // 革命判定：「4枚以上同一ランク役」かつ「階段役は除外」（冗長明示）
    _mostCommonRank(cards) {
        const ranks = {};
        cards.forEach(c => {
            if (c.isJoker) return;
            ranks[c.rank] = (ranks[c.rank] || 0) + 1;
        });
        let max = 0, maxRank = null;
        for (const r in ranks) {
            if (ranks[r] > max) { max = ranks[r]; maxRank = parseInt(r); }
        }
        return maxRank;
    }
    isRevolutionCombo(played) {
        if (played.length < 4) return false;
        if (this.isMoveStairs(played)) return false; // 4枚以上階段は革命とならない
        const mainRank = this._mostCommonRank(played);
        if (mainRank === null) return false;
        let sameCount = played.filter(c => c.rank === mainRank || c.isJoker).length;
        return sameCount === played.length;
    }

    getPlayableGroups(hand) {
        let groups = [];
        const prevIsStairs = this.prevIsStairs();
        const lastCount = this.lastPlayedCount || 1;
        const lastRank = this.lastPlayedRank;
        const isJBack = this.jBackActive;
        const isRev = this.revolution;

        if (prevIsStairs) {
            for (let s of ['♣', '♦', '♥', '♠']) {
                let suitCards = hand.filter(c => c.suit === s && !c.isJoker).map(c => c.rank).sort((a, b) => a - b);
                for (let i = 0; i <= suitCards.length - lastCount; i++) {
                    let ok = true;
                    for (let j = 1; j < lastCount; j++) {
                        if (suitCards[i + j] !== suitCards[i] + j) { ok = false; break; }
                    }
                    if (ok) {
                        let seq = [];
                        for (let j = 0; j < lastCount; j++) {
                            seq.push(hand.find(c => c.suit === s && c.rank === suitCards[i] + j));
                        }
                        const prev = this.lastPlayedCards.map(c => c.rank).sort((a, b) => a - b)[0];
                        const curr = suitCards[i];
                        if (!isRev) {
                            if (curr > prev) groups.push(seq);
                        } else {
                            if (curr < prev) groups.push(seq);
                        }
                    }
                }
            }
            return groups;
        }
        let validCards = [];
        if (isJBack) {
            if (this.isRevJBack()) {
                validCards = hand.filter(c => (!c.isJoker && c.rank >= 12) || c.isJoker);
            } else {
                validCards = hand.filter(c => !c.isJoker && c.rank <= 11);
            }
        } else {
            validCards = hand.slice();
        }
        let group = {};
        for (let c of validCards) {
            if (!group[c.rank]) group[c.rank] = [];
            group[c.rank].push(c);
        }
        [lastCount].forEach(needCount => {
            Object.values(group).forEach(cards => {
                if (cards.length >= needCount) {
                    groups.push(cards.slice(0, needCount));
                }
            });
        });
        if (!isJBack && !prevIsStairs) {
            const joker = hand.find(c => c.isJoker);
            if (joker && lastCount === 1) {
                if (this.lastPlayedCards.length === 0 || this.rankValue(joker) > lastRank) {
                    groups.push([joker]);
                }
            }
        }
        groups = groups.filter(cards => {
            if (isJBack && !this.isRevJBack()) {
                if (this.lastPlayedCards.length > 0 && !prevIsStairs) {
                    return this.rankValue(cards[0]) < lastRank;
                }
                return true;
            } else if (this.isRevJBack()) {
                if (this.lastPlayedCards.length > 0 && !prevIsStairs) {
                    return this.rankValue(cards[0]) > lastRank;
                }
                return true;
            } else if (isRev) {
                if (this.lastPlayedCards.length > 0 && !prevIsStairs) {
                    return this.rankValue(cards[0]) < lastRank;
                }
                return true;
            } else {
                if (this.lastPlayedCards.length > 0 && !prevIsStairs) {
                    return this.rankValue(cards[0]) > lastRank;
                }
                return true;
            }
        });
        return groups;
    }

    npcAction(pl) {
        if (pl.finished) return;
        if (this.spade3BackPending) {
            const card = pl.hand.find(c => c.suit === '♠' && c.rank === 3);
            if (card) return this.handlePlay(pl.name, [{ suit: '♠', rank: 3 }]);
            else return this.handlePass(pl.name);
        }
        if (this.waitingForSevenCard && this.waitingForSevenCardPlayer === pl.name) {
            for (let i = 0; i < this.needSevenCount; i++) {
                let maxCard = pl.hand[0];
                for (const c of pl.hand) {
                    if (c.rank > maxCard.rank || c.isJoker) maxCard = c;
                }
                pl.hand.splice(pl.hand.indexOf(maxCard), 1);
                let targetIdx = this.getNextAlive(this.currentTurn);
                const target = this.players[targetIdx];
                target.hand.push(maxCard);
                target.hand.sort((a, b) => a.rank - b.rank);
            }
            this.waitingForSevenCard = false;
            this.waitingForSevenCardPlayer = null;
            this.needSevenCount = 1;
            this.currentTurn = this.getNextAlive(this.currentTurn);
            this.broadcastState();
            this.checkAndHandleNPC();
            return;
        }
        const playable = this.getPlayableGroups(pl.hand);
        let best = null;
        if (playable.length > 0) {
            if ((this.revolution && !this.jBackActive) || (this.jBackActive && !this.isRevJBack())) {
                best = playable.reduce((a, b) => (this.rankValue(a[0]) > this.rankValue(b[0]) ? a : b));
            } else {
                best = playable.reduce((a, b) => (this.rankValue(a[0]) < this.rankValue(b[0]) ? a : b));
            }
            this.handlePlay(pl.name, best.map(c => ({ suit: c.suit, rank: c.rank })));
        } else {
            this.handlePass(pl.name);
        }
    }

    // 七渡しカード受信（複数枚対応）
    handleSevenGive(playerName, dataCards) {
        if (!this.waitingForSevenCard || this.waitingForSevenCardPlayer !== playerName) return;
        const pl = this.getPlayer(playerName);
        if (!pl || pl.finished) return;
        if (dataCards.length !== this.needSevenCount) return;

        let giveCards = [];
        for (const d of dataCards) {
            let card = pl.hand.find(c => c.suit === d.suit && String(c.rank) === String(d.rank));
            if (!card) return;
            giveCards.push(card);
        }
        giveCards.forEach(c => {
            const idx = pl.hand.indexOf(c);
            if (idx !== -1) pl.hand.splice(idx, 1);
        });
        let targetIdx = this.getNextAlive(this.currentTurn);
        const target = this.players[targetIdx];
        giveCards.forEach(c => {
            target.hand.push(c);
        });
        target.hand.sort((a, b) => a.rank - b.rank);

        this.waitingForSevenCard = false;
        this.waitingForSevenCardPlayer = null;
        this.needSevenCount = 1;
        this.currentTurn = this.getNextAlive(this.currentTurn);
        this.broadcastState();
        this.checkAndHandleNPC();
    }

    handlePlay(playerName, dataCards) {
        if (!this.started) return;
        const pl = this.getPlayer(playerName); if (!pl || pl.finished) return;
        if (this.players[this.currentTurn].name !== playerName) return;

        // --- 必ず出したカードを手札から先に削除（7含む） ---
        const played = [];
        for (const d of dataCards) {
            if (d.suit === 'J' || d.rank == 16) {
                const j = pl.hand.find(c => c.isJoker); if (!j) return;
                played.push(j);
            } else {
                let rankNum = typeof d.rank === 'number' ? d.rank : Number({
                    'J': 11, 'Q': 12, 'K': 13, 'A': 14, '2': 15
                }[d.rank] || d.rank);
                const idx = pl.hand.findIndex(c => !c.isJoker && c.suit === d.suit && c.rank === rankNum);
                if (idx === -1) return;
                played.push(pl.hand[idx]);
            }
        }
        if (played.length === 0) return;

        played.forEach(c => {
            const idx = pl.hand.indexOf(c);
            if (idx !== -1) pl.hand.splice(idx, 1);
        });

        // --- 七渡し ---
        let sevenCount = played.filter(c => !c.isJoker && c.rank === 7).length;
        if (sevenCount > 0) {
            if (pl.isNPC) {
                for (let i = 0; i < sevenCount; i++) {
                    let maxCard = pl.hand[0];
                    for (const c of pl.hand) {
                        if (c.rank > maxCard.rank || c.isJoker) maxCard = c;
                    }
                    pl.hand.splice(pl.hand.indexOf(maxCard), 1);
                    let targetIdx = this.getNextAlive(this.currentTurn);
                    const target = this.players[targetIdx];
                    target.hand.push(maxCard);
                    target.hand.sort((a, b) => a.rank - b.rank);
                }
            } else {
                this.waitingForSevenCard = true;
                this.waitingForSevenCardPlayer = playerName;
                this.needSevenCount = sevenCount;
                this.broadcastState();
                return;
            }
        }

        // --- スペ3返し（ジョーカー単独出し直後のみ） ---
        if (this.spade3BackPending) {
            if (dataCards.length !== 1 || !(dataCards[0].suit === '♠' && (dataCards[0].rank == 3 || dataCards[0].rank === '3'))) return;
            const card = played[0];
            this.lastMoveInfo = { player: pl.name, move: 'play', cards: [card], special: 'スペ3返し可能' };
            this.lastPlayedCards = []; this.lastPlayedRank = null; this.lastPlayedCount = 0; this.passCount = 0;
            this.spade3BackPending = false;
            this.lastPlayWasStairs = false;
            this.jBackActive = false;
            if (pl.hand.length === 0) pl.finished = true;
            this.currentTurn = this.getNextAlive(this.currentTurn);
            this.broadcastState();
            this.checkAndHandleNPC();
            return;
        }

        // --- 革命判定 ---
        let revToggled = false;
        let isRevolution = this.isRevolutionCombo(played);
        if (isRevolution) {
            this.revolution = !this.revolution;
            revToggled = true;
        }

        // --- 8切り ---
        let isEightCut = played.some(c => !c.isJoker && c.rank === 8);

        // --- Jバック ---
        let isJBack = played.every(c => !c.isJoker && c.rank === 11);
        if (isJBack) {
            this.jBackActive = true;
        }

        // --- 場情報更新 ---
        let stairs = this.isMoveStairs(played);
        this.lastPlayedCards = [...played];
        this.lastPlayedCount = played.length;
        this.lastPlayedRank = stairs ? played.map(c => c.rank).sort((a, b) => a - b)[0] : this.rankValue(played[0]);
        this.lastPlayerIndex = this.currentTurn;
        this.passCount = 0;
        this.lastPlayWasStairs = stairs;

        let jokerPlayed = (played.length === 1 && played[0].isJoker);
        if (jokerPlayed) this.spade3BackPending = true; else this.spade3BackPending = false;

        if (pl.hand.length === 0) { pl.finished = true; }
        if (this.isGameOver()) { this.endGame(); this.broadcastState(); return; }

        if (isEightCut) {
            this.lastPlayedCards = [];
            this.lastPlayedRank = null;
            this.lastPlayedCount = 0;
            this.passCount = 0;
            this.lastPlayWasStairs = false;
            this.jBackActive = false;
            this.spade3BackPending = false;
            if (!pl.finished) { /* 継続 */ }
            else { this.currentTurn = this.getNextAlive(this.currentTurn); }
        } else {
            this.currentTurn = this.getNextAlive(this.currentTurn);
        }
        if (!isJBack && this.lastPlayedCards.length === 0) {
            this.jBackActive = false;
        }

        let specialArr = [];
        if (sevenCount) specialArr.push('7渡し');
        if (revToggled) specialArr.push(this.revolution ? '革命' : '革命返し');
        if (isEightCut) specialArr.push('8切り発動');
        if (isJBack) specialArr.push('Jバック発動');
        if (jokerPlayed) specialArr.push('スペ3返し可能');
        if (stairs) specialArr.push('階段');
        if (this.jBackActive && !isJBack) specialArr.push('Jバック中');
        if (this.isRevJBack && typeof this.isRevJBack === 'function' && this.isRevJBack()) specialArr.push('革命＋Jバック中');
        this.lastMoveInfo = { player: pl.name, move: 'play', cards: played, special: specialArr.join('・') || null };

        this.broadcastState();
        this.checkAndHandleNPC();
    }

    handlePass(playerName) {
        if (!this.started) return;
        if (this.spade3BackPending) {
            this.spade3BackPending = false;
            this.lastPlayedCards = []; this.lastPlayedRank = null; this.lastPlayedCount = 0; this.passCount = 0;
            this.lastPlayWasStairs = false;
            this.currentTurn = this.getNextAlive(this.currentTurn);
            this.lastMoveInfo = { player: playerName, move: 'pass', special: 'スペ3返しパス（場流し）' };
            this.jBackActive = false;
            this.broadcastState();
            this.checkAndHandleNPC();
            return;
        }
        const pl = this.getPlayer(playerName); if (!pl || pl.finished) return;
        if (this.players[this.currentTurn].name !== playerName) return;
        if (this.lastPlayedCards.length === 0) return;
        this.passCount++;
        this.lastMoveInfo = { player: pl.name, move: 'pass', special: null };
        const active = this.players.filter(p => !p.finished).length;
        let need;
        if (this.lastPlayerIndex !== null && !this.players[this.lastPlayerIndex].finished) {
            need = active - 1;
        } else need = active;
        if (this.passCount >= need) {
            this.lastPlayedCards = []; this.lastPlayedRank = null; this.lastPlayedCount = 0; this.passCount = 0;
            this.lastPlayWasStairs = false;
            this.currentTurn = (this.lastPlayerIndex !== null && !this.players[this.lastPlayerIndex].finished)
                ? this.lastPlayerIndex
                : this.getNextAlive(this.currentTurn);
            this.lastMoveInfo.special = this.lastMoveInfo.special ? this.lastMoveInfo.special + '・場流し' : '場流し';
            this.jBackActive = false;
        } else {
            this.currentTurn = this.getNextAlive(this.currentTurn);
        }
        if (this.isGameOver()) { this.endGame(); }
        this.broadcastState();
        this.checkAndHandleNPC();
    }

    isGameOver() { return this.started && this.players.filter(p => !p.finished).length <= 1; }

    endGame() {
        const last = this.players.find(p => !p.finished); if (last) last.finished = true;
        const ordered = [...this.players].sort((a, b) => a.hand.length - b.hand.length);
        const n = ordered.length;
        ordered.forEach((p, i) => {
            p.rankTitle = (i === 0) ? '大富豪' : (i === 1 && n >= 4) ? '富豪' : (i === n - 2 && n >= 4) ? '貧民' : (i === n - 1) ? '大貧民' : '平民';
        });
        if (this.lastChampion) {
            const champ = this.getPlayer(this.lastChampion);
            if (champ && champ.rankTitle !== '大富豪') champ.rankTitle = '大貧民';
        }
        this.lastChampion = ordered[0].name;
        this.started = false;
    }

    buildState() {
        const gameOver = this.isGameOver();
        return {
            type: gameOver ? 'final' : 'update',
            room: this.roomId,
            started: this.started,
            gameOver,
            players: this.players.map(p => ({
                name: p.name, cardsCount: p.hand.length, finished: p.finished, connected: p.connected || p.isNPC
            })),
            field: { cards: this.lastPlayedCards.map(c => c.toString()) },
            currentTurn: this.started ? this.players[this.currentTurn].name : null,
            revolution: this.revolution,
            ranking: gameOver ? this.players.map(p => ({ name: p.name, title: p.rankTitle })) : null,
            lastMove: this.lastMoveInfo ? {
                ...this.lastMoveInfo,
                cards: this.lastMoveInfo.cards?.map(c => c.toString())
            } : null,
            waitingForSevenCard: this.waitingForSevenCard,
            waitingForSevenCardPlayer: this.waitingForSevenCardPlayer,
            needSevenCount: this.needSevenCount
        };
    }

    broadcastState() {
        const st = this.buildState();
        this.players.forEach(p => {
            if (p.conn && p.connected) {
                p.conn.send(JSON.stringify({ ...st, yourHand: p.hand.map(c => c.toString()) }));
            }
        });
    }

    sendStateToPlayer(name) {
        const p = this.getPlayer(name); if (p && p.conn && p.connected) {
            const st = this.buildState();
            p.conn.send(JSON.stringify({ ...st, yourHand: p.hand.map(c => c.toString()) }));
        }
    }

    checkAndHandleNPC() {
        if (!this.started) return;
        const cur = this.players[this.currentTurn];
        if (cur && cur.isNPC && !cur.finished) {
            setTimeout(() => this.npcAction(cur), 500);
        }
    }
}

module.exports = GameRoom;




















server/server.js













// ======================================
//  server/server.js  （2025-07 冗長・省略ゼロ）
// ======================================
const http = require('http');
const path = require('path');
const express = require('express');
const WebSocketServer = require('ws').Server;
const GameRoom = require('./GameRoom');

const app = express();
app.use(express.static(path.join(__dirname, '..', 'public')));

// ---------- HTTP サーバ ----------
const server = http.createServer(app);

// ---------- WebSocket ----------
const wss = new WebSocketServer({ server });

// ---------- ルーム管理 ----------
const rooms = {};  // roomId -> GameRoom

// ----- 入退室／ゲーム進行メッセージ -----
wss.on('connection', ws => {
  ws.on('message', msg => {
    let data;
    try { data = JSON.parse(msg); } catch (e) { return; }
    const { type } = data;

    // ----- join -----
    if (type === 'join') {
      const { room: roomId, name } = data;
      if (!roomId || !name) {
        ws.send(JSON.stringify({ type: 'error', message: '名前またはルームID未指定' }));
        return;
      }

      let room = rooms[roomId];
      if (!room) { room = new GameRoom(roomId); rooms[roomId] = room; }

      if (room.started && !room.getPlayer(name)) {
        ws.send(JSON.stringify({ type: 'error', message: 'ゲーム進行中のため入室不可' }));
        return;
      }

      const res = room.addPlayer(name, ws);
      if (!res.ok) {
        ws.send(JSON.stringify({ type: 'error', message: res.error }));
        return;
      }

      ws.roomId = roomId;
      ws.playerName = name;
      room.broadcastState();
      if (room.started) room.sendStateToPlayer(name);
      return;
    }

    // 以降はルーム必須
    const room = rooms[ws.roomId]; if (!room) return;

    // ----- start -----
    if (type === 'start') {
      const host = room.players[0]?.name;
      if (ws.playerName === host && !room.started) room.startGame();
      return;
    }

    // ----- reset -----
    if (type === 'reset') {
      const host = room.players[0]?.name;
      if (ws.playerName === host && !room.started) room.startGame();
      return;
    }

    // ----- play / pass -----
    if (type === 'play') room.handlePlay(ws.playerName, data.cards);
    if (type === 'pass') room.handlePass(ws.playerName);

    // ----- 七渡し -----
    if (type === 'seven-give') room.handleSevenGive(ws.playerName, data.cards);
  });

  // ----- 切断 -----
  ws.on('close', () => {
    const roomId = ws.roomId, name = ws.playerName;
    if (!roomId || !rooms[roomId]) return;

    const room = rooms[roomId];
    const pl = room.getPlayer(name);
    if (pl) { pl.connected = false; pl.conn = null; room.broadcastState(); }

    if (room.players.every(p => !p.connected)) {
      if (!room._deleteTimer) {
        room._deleteTimer = setTimeout(() => {
          delete rooms[roomId];
          console.log(`Room ${roomId} removed after 5-minute grace.`);
        }, 5 * 60 * 1000);
      }
    } else {
      if (room._deleteTimer) {
        clearTimeout(room._deleteTimer);
        room._deleteTimer = null;
      }
    }
  });
});

// ---------- 起動 ----------
const PORT = process.env.PORT || 3000;
server.listen(PORT, () => console.log(`Server listening on ${PORT}`));













各ルールのロジック説明（サーバー実装視点）
1. 8切り
説明: 場に8を含むカードセット（単体でもペアや階段でも可）が出された場合、その時点で場のカードがすべて流れ（リセット）される。次のプレイヤーは任意のカードから新たに出せる。

ポイント: 8が含まれる組み合わせなら必ず適用。

2. 革命
説明: 4枚以上の同じ数字（または同じランク）が同時に出された場合、場が「革命」状態となり、カードの強さ（出せる順）が逆転する（例：2＞A＞K…→3＞4＞…J＞Q＞K＞A＞2）。

ポイント: 革命中かどうかを状態フラグで管理する。

3. Jバック
説明: 場にJ（ジャック）のみで構成されるカード（単体またはペア等）が出された場合、出せるカードの強弱が次のターンのみ一時的に逆転する（ミニ革命、1ターン限定）。

ポイント: 「Jバック状態」フラグを次ターン終了まで立てる。

4. 階段（シーケンス）
説明: 2枚以上の連番かつ同じスートのカード（例：5♠,6♠,7♠）を一度に出すことができる。場にも階段が出ている場合、出すには「同じ枚数」「連番」「強さが上（革命中は下）」が必要。

ポイント: 手札・場札ともに階段構成の妥当性チェックを行う。

5. スペ3返し
説明: ジョーカー（JOKER）が場に出された直後のターンでのみ、スペードの3（3♠）を出すことでJOKERを打ち消し、そのまま自分のターンとして継続できる（※他の3では不可）。

ポイント: 「前ターンJOKERが出た」状態でのみ有効。通常時の3♠は普通の3扱い。

6. 七渡し
説明: 7を含むカードを出した場合、任意の他プレイヤーに手札1枚を渡さなければならない（渡す相手は自分の次の番の人、複数枚なら枚数分）。

ポイント: 7が複数含まれる場合はその枚数分渡す処理を行う。手動選択のUI設計も必要。cpuはランダム

7. JOKERの特殊性
説明: ジョーカーは任意のカード（数字、スート、出し方）に「変身」できる。
例：5♠として使えば5♠として扱われる（階段やペアなどの判定にも含める）。
ジョーカーがJバックや8切り等のトリガー役になった場合も、そのルールを適用。

ルール競合時の具体的処理例
1. 革命中に8切りされた場合

革命状態は継続したまま場が流れる（革命解除には「革命返し（もう一度同じ役が出る）」が必要）。

2. ジョーカー階段出し（例：6♠,7♠,JOKER→8♠として出す）＋8切り　＋7渡し

ジョーカーが8♠として出された場合も8切りが発動。この場合は7も含まれているため7渡しも発動。

3. ジョーカー単独出し → 次の人がスペ3返し（3♠出し）

前ターンでJOKER単独出し→次プレイヤーが3♠を出せばJOKERが打ち消され、手番が継続。3♠以外のカードは通常処理。ただし階段やペアでjokerが出された場合はjokerは階段やペアのカードとしてふるまうのでスぺードの3は出せない。あくまでも単独だしの場合のみ有効

4. 革命＋Jバックの競合

革命中にJバックが出された場合、次ターンのみ「通常の順序」に一時的に戻り、Jバック終了後は再び革命順へ。

5. 階段＋8切り（8を含む階段）

例えば6♠,7♠,8♠を出したら、8切りが発動し、場がリセットされる。(この場合は7渡しも発動)

6. 七渡し＋8切り（7と8のペアなどで同時出し）

7と8を同時に含む場合、両方の効果が発動。
例：7,8のペア出し→まず手札渡し処理、その後場流し処理。

7. 革命返しと他ルール

革命返し（革命状態中に再び4枚出し）すると革命が元に戻る。

革命返しと8切りが同時に発生する（例：8,8,8,8出し）は両方発動（革命解除→場流し）。

説明例まとめ
「場に出したカード（単体・複数・階段）にルール適用トリガー（8、7、J、ジョーカーなど）が含まれる場合、発動順序は

手札渡し（七渡し）→

革命判定（4枚役/革命）→

8切り（場流し）→

Jバック（一時逆転）
の順でチェック。各ルールは競合時にも個別に判定し、複数同時発動も可。
ジョーカーは変身先のカードとしてすべてのロジックで判定。」


自分の手札が0枚になっても試合が終わらず、手札がないにも関わらず自分の番が回ってきた
階段で5,6,7,jokerを出した際、出すボタンを選択後、jokerを4or8にするのか選択するuiを作成
仮に8が選択された場合、場では革命発生→7渡し→8切り発動
現状は革命のフラグ判定が4枚の同じペアのみになっており、階段でも革命を起こすように改善


それ以外の、
革命時にjバック発動表示されても小さい順になるバグ
joker→スぺ3後流れないバグ
などなどは改善されました

冗長性を第一に絶対順守し、元コードから勝手な判断でコードを削除することは絶対に許しません
これはこのプロジェクトでの以下絶対のルールとします
追加するコードが長くなり現状のコード数を超える場合はコード数を現状のコード数と同じ数にとどめることを優先しませんむしろ可能な限り最高のコードにしてください

上2つに対して最高の解決策を求め複数提案し、最適な解決策を全文、必ず省略を一切することなく提示してください。根本解決を求めます

7を二枚とjoker1枚で7渡しをする際
7渡しとして効果が発動するのですが、7,2枚分しか発動しません
jokerが7になったのだから効果も7扱いにしてください

10,j,K,jokerで階段を出そうとしたときjoekrの返信先を選択してくださいと出てきたのだが、選択画面が、現在の手札のカードしか選択できなかった
本来階段をするためにjとkの間に一枚なければならないため(今回はスペード)joker→スぺードのqにならないといけない

だができないので試しに手札のKを選択したのだが
すると10,j,K,Kと大富豪のルールとは乖離したものを場に出すことになった

jokerの変身先を選択する際は現在の7渡しのuiのようにして
手札とは別に
例えば  
3,4,6,jokerの場合は階段を成立させるためには4,6の間の5以外選択肢がないためこの分岐は行われない
3,4,5,jokerの場合は階段を成立させるためにはjokerを2or6に変化させる必要がある
この場合はjokerを2or6どちらにするかというuiを出す必要がある
3,jokerのように3の2枚ペアこの場合もjokerの選択先は一つに絞られるため選択uiのフラグは発生しない

クローバーのk,a,2とjokerで階段を作ろうと思った
その際jokerの返信先を選んでくださいというuiが出て枠内にクローバーの3が出てきた
今回もk,a,2なので階段を成立させるにはjokerは無条件にクローバーのqになる必要がある

クローバーの5,7,8,jokerを選択した際もjoker→クローバーの6に無条件になる必要があるのに
選択画面のuiではクローバーの9が出てきた
選択したカードの最大値+1になるような雑なコードになっている可能性がある

革命が壊れています
4,4,4,jokerを出したのに革命が発動されなかった
その後このターンにnpcが
10,10,10,10を出したら革命が発動された