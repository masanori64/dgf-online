ç¾åœ¨ã®å®Ÿè£…çŠ¶æ³ã¨å®Œæˆåº¦ï¼ˆ2025å¹´7æœˆæ™‚ç‚¹ã¾ã¨ã‚ï¼‰
âœ…å®Ÿè£…æ¸ˆã¿æ©Ÿèƒ½ï¼ˆã‚³ãƒ¼ãƒ‰ãƒ™ãƒ¼ã‚¹æœ€æ–°ï¼‰
ã‚µãƒ¼ãƒãƒ¼/ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆé€šä¿¡ï¼šNode.js + Express + WebSocketã§ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ é€šä¿¡

ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆUIï¼šHTML/CSS/JSï¼ˆæ‰‹æœ­è¡¨ç¤ºãƒ»é¸æŠãƒ»ã‚«ãƒ¼ãƒ‰å‡ºã—ãƒ»ãƒ‘ã‚¹ãƒ»çµæœè¡¨ç¤ºï¼‰

åŸºæœ¬ãƒ«ãƒ¼ãƒ«ï¼šæ‰‹æœ­å‡ºã—ï¼ãƒ‘ã‚¹ï¼8åˆ‡ã‚Šï¼é©å‘½ï¼Jãƒãƒƒã‚¯ï¼éšæ®µ

NPCè‡ªå‹•è£œå……&ãƒ­ã‚¸ãƒƒã‚¯ï¼šè¶³ã‚Šãªã„å ´åˆè‡ªå‹•å‚åŠ ã—ã€å˜ç´”ãªãƒ­ã‚¸ãƒƒã‚¯ã§è‡ªå‹•ãƒ—ãƒ¬ã‚¤

å‹æ•—åˆ¤å®šï¼é †ä½ä»˜ã‘ï¼šå¤§å¯Œè±ªã€œå¤§è²§æ°‘ã¾ã§é †ä½ä»˜ã‘ã—çµæœè¡¨ç¤º

å†æ¥ç¶šå¯¾å¿œï¼šåŒåã§å…¥å®¤ã™ã‚‹ã¨æ‰‹æœ­ã‚„çŠ¶æ…‹ã‚’å¾©å¸°

WebSocketãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ åŒæœŸï¼šå…¨ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã¸çŠ¶æ…‹å³æ™‚åæ˜ 

UMLè¨­è¨ˆï¼ˆã‚¯ãƒ©ã‚¹å›³ãƒ»ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ãƒ»ã‚¢ã‚¯ãƒ†ã‚£ãƒ“ãƒ†ã‚£ãƒ»ãƒ¦ãƒ¼ã‚¹ã‚±ãƒ¼ã‚¹ï¼‰ã¨ã®ä¸€è²«æ€§

ğŸç¾æ™‚ç‚¹ã®è‡´å‘½çš„ãƒã‚°ãƒ»ç›´ã™ã¹ãç‚¹ï¼ˆå„ªå…ˆåº¦ã¤ãï¼‰
å„ªå…ˆåº¦	å†…å®¹	çŠ¶æ³ãƒ»å‚™è€ƒ
ğŸ”´é«˜	è‡ªåˆ†ã®æ‰‹æœ­ãŒ0æšã§ã‚‚ç•ªãŒå›ã£ã¦ãã‚‹	0æšæ™‚ã«ä¸ŠãŒã‚Šå‡¦ç†ãŒä¸å®Œå…¨ã€‚ã‚¿ãƒ¼ãƒ³å‡¦ç†ãŒãƒ«ãƒ¼ãƒ—ã€‚
ğŸ”´é«˜	éšæ®µã§JOKERå‡ºã—æ™‚ã€å¤‰èº«å…ˆï¼ˆ4/8ï¼‰é¸æŠUIãŒç„¡ã„	ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒJOKERã®å‡ºã—æ–¹ã‚’æ˜ç¤ºã§ããšã€ãƒ­ã‚¸ãƒƒã‚¯ä¸ä¸€è‡´ã€‚
ğŸŸ ä¸­	éšæ®µã§é©å‘½ãŒç™ºå‹•ã—ãªã„	4æšéšæ®µç­‰ã§é©å‘½ãŒèµ·ã“ã‚‹ã¹ãã ãŒã€åŒãƒ©ãƒ³ã‚¯ãƒšã‚¢ã®ã¿ã«ãªã£ã¦ã„ã‚‹ã€‚
ğŸŸ ä¸­	é©å‘½æ™‚ã«Jãƒãƒƒã‚¯ã®é †ãŒé€†ã«ãªã‚‰ãªã„ãƒã‚°	çŠ¶æ…‹ãƒ•ãƒ©ã‚°ã®æ‰±ã„ã«ä¸æ•´åˆã€‚
ğŸŸ¢ä½	8åˆ‡ã‚Šãƒ»ã‚¹ãƒš3è¿”ã—å‘¨è¾ºã®æµã—å‡¦ç†	è»½å¾®ãªè¡¨ç¤ºãƒ»ãƒ­ã‚¸ãƒƒã‚¯ã®é•å’Œæ„Ÿã€‚

ğŸ”œè¿½åŠ ãƒ»æ”¹ä¿®ã™ã¹ãä¸»ãªæ©Ÿèƒ½ãƒªã‚¹ãƒˆ
1.ã‚¿ãƒ¼ãƒ³è‡ªå‹•ã‚¹ã‚­ãƒƒãƒ—ï¼†ä¸ŠãŒã‚ŠæŠœã‘ç®¡ç†

*æ‰‹æœ­0æšãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¯å³ã€Œfinishedã€ã¨ã—ã€ã‚¿ãƒ¼ãƒ³ã‚’ã‚¹ã‚­ãƒƒãƒ—

*å…¨å“¡ä¸ŠãŒã£ãŸå ´åˆã®ãƒ«ãƒ¼ãƒ—é˜²æ­¢ï¼ˆisGameOver/getNextAliveã®å¼·åŒ–ï¼‰

2.éšæ®µï¼‹JOKER UI/ãƒ­ã‚¸ãƒƒã‚¯

*ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒJOKERã‚’å‡ºã™ã¨ãã€ã©ã®ã‚«ãƒ¼ãƒ‰ã¨ã—ã¦æ‰±ã†ã‹UIé¸æŠâ†’ã‚µãƒ¼ãƒã¸ä¼é”

*ã‚µãƒ¼ãƒã¯JOKERå¤‰èº«å…ˆã‚’æ˜ç¤ºçš„ã«å—ã‘å–ã‚Šã€å½¹åˆ¤å®šãƒ»ãƒ«ãƒ¼ãƒ«åˆ¤å®šã«åˆ©ç”¨

3.éšæ®µã§ã®é©å‘½åˆ¤å®š

*åŒãƒ©ãƒ³ã‚¯4æšã ã‘ã§ãªãã€ã€Œ4æšä»¥ä¸Šé€£ç¶šéšæ®µã€ã§ã‚‚é©å‘½ç™ºå‹•ã¸ãƒ­ã‚¸ãƒƒã‚¯å¼·åŒ–

*ã‚¯ãƒ©ã‚¹å›³ãƒ»ã‚·ãƒ¼ã‚±ãƒ³ã‚¹å›³ã‚‚ä¿®æ­£

4.Jãƒãƒƒã‚¯ï¼‹é©å‘½çŠ¶æ…‹ã®å‡¦ç†åˆ†å²

*Jãƒãƒƒã‚¯ä¸­ã¯é †åºãŒã€Œä¸€æ™‚çš„ã«ã€å…ƒã«æˆ»ã‚‹ã€ãã®å¾Œå†ã³é©å‘½é †ã¸æˆ»ã‚‹ã‚ˆã†ã«

*çŠ¶æ…‹é·ç§»ã®è¦‹ç›´ã—ã¨ãƒ†ã‚¹ãƒˆ

5.ã‚¹ãƒš3è¿”ã—ï¼8åˆ‡ã‚Šãªã©ã®ç‰¹æ®Šæµã—ã®æ˜ç¤ºåŒ–

*UIè¡¨ç¤ºã‚‚ã€Œå ´æµã—ã€ã€Œé©å‘½è¿”ã—ã€ãªã©æ˜ç¢ºãªãƒ­ã‚°ã‚„ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’è¿½åŠ 

6.JOKERå¤‰èº«UIã®è¨­è¨ˆ

*ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆå´ï¼šéšæ®µé¸æŠæ™‚ã«JOKERã‚’ã‚¯ãƒªãƒƒã‚¯â†’å¤‰èº«å…ˆå€™è£œã‚’ãƒ¢ãƒ¼ãƒ€ãƒ«è¡¨ç¤ºã—é¸æŠâ†’ãã®å†…å®¹ã§playé€ä¿¡

ğŸ”¶ ä»Šå¾Œã®æ©Ÿèƒ½ã”ã¨ã®è¨­è¨ˆæ–¹é‡
ãƒ­ãƒ¼ã‚«ãƒ«ãƒ«ãƒ¼ãƒ«ON/OFF

ãƒ«ãƒ¼ãƒ ä½œæˆæ™‚ã«ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹å¼ã§ä»»æ„ãƒ«ãƒ¼ãƒ«é¸æŠå¯èƒ½ã¨ã™ã‚‹

ã‚µãƒ¼ãƒå´ã¯room.settingsï¼ˆbooleanå€¤ã§æŒã¤ï¼‰ã§åˆ†å²

è¦³æˆ¦ãƒ¢ãƒ¼ãƒ‰

é€”ä¸­å…¥å®¤è€…ã¯role: 'spectator'ã§å‚åŠ 

ãƒ—ãƒ¬ã‚¤ãƒœã‚¿ãƒ³ãƒ»æ‰‹æœ­UIéè¡¨ç¤ºã€ãƒãƒ£ãƒƒãƒˆã®ã¿åˆ©ç”¨å¯èƒ½

ã‚µãƒ¼ãƒå´ã§è¦³æˆ¦ãƒ¦ãƒ¼ã‚¶ã«ã¯çŠ¶æ…‹ã®ã¿é€ä¿¡

ãƒãƒ£ãƒƒãƒˆ

ãƒ«ãƒ¼ãƒ å…¨ä½“ãƒãƒ£ãƒƒãƒˆï¼ˆãƒ•ã‚©ãƒ¼ãƒ ï¼‹å±¥æ­´æ¬„ï¼‰

ã‚µãƒ¼ãƒ: type: 'chat' ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸å—ä¿¡ã§å…¨å“¡ã«é…ä¿¡

ç¸›ã‚Šå®Ÿè£…

å ´ã«å‡ºã•ã‚ŒãŸã‚¹ãƒ¼ãƒˆã‚’è¨˜æ†¶ã—ã€ä»¥é™ã‚¿ãƒ¼ãƒ³ã§ç¸›ã‚Šæ¡ä»¶ã‚’è¿½åŠ 

room.lastPlayedSuit è¿½åŠ ã—ã€handlePlayæ™‚ã«åˆ¤å®š

UIæ”¹å–„

ç¾åœ¨ã‚¿ãƒ¼ãƒ³/æ®‹ã‚Šæ‰‹æœ­æšæ•°/ãƒ‘ã‚¹å›æ•°ç­‰ã‚’å¼·èª¿

NPCãƒ»è¦³æˆ¦è€…ã®åŒºåˆ¥ã‚‚åˆ†ã‹ã‚‹ã‚ˆã†ãƒ©ãƒ™ãƒ«è¿½åŠ 

ãã®ä»–ï¼ˆé€šä¿¡ãƒ»ç®¡ç†ï¼‰

ãƒ­ãƒ“ãƒ¼ï¼šrooms[]ä¸€è¦§API/ç”»é¢

ã‚¿ãƒ¼ãƒ³ã‚¿ã‚¤ãƒãƒ¼ï¼šyour-turnæ™‚setTimeoutã§è‡ªå‹•ãƒ‘ã‚¹

ã€è¨­è¨ˆæ›¸ã€‘å…¨ä½“ç²’åº¦
â— ã‚¿ãƒ¼ãƒ³ç®¡ç†ã¨ä¸ŠãŒã‚ŠæŠœã‘
GameRoom.jsã®getNextAliveãƒ¡ã‚½ãƒƒãƒ‰ã‚’å…¨ã¦ã€Œæœªä¸ŠãŒã‚Šï¼ˆfinished=falseï¼‰ã€ã®ã¿é¸ã¶ã‚ˆã†ã«ãƒ«ãƒ¼ãƒ—å¼·åŒ–

ä¸ŠãŒã£ãŸç¬é–“ã‚¿ãƒ¼ãƒ³ã‚’è‡ªå‹•ã§é£›ã°ã™

handlePlay/handlePassç­‰ã€ã‚¿ãƒ¼ãƒ³çµ‚äº†å¾Œå¿…ãšã€Œç”Ÿãã¦ã‚‹ã€ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¸é·ç§»

isGameOver()ã¯æ®‹ã‚Š1äººä»¥ä¸‹ã§ã™ãçµ‚äº†

â— éšæ®µ+JOKER UIï¼ˆã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆï¼‰
playSelectedæ™‚ã€JOKERå«ã‚€éšæ®µãŒé¸æŠã•ã‚Œã¦ã„ãŸã‚‰

å¤‰èº«å…ˆï¼ˆrank, suitï¼‰å€™è£œã‚’è‡ªå‹•æŠ½å‡ºã—ãƒ¢ãƒ¼ãƒ€ãƒ«ã§è¡¨ç¤º

ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒæ˜ç¤ºé¸æŠâ†’cardsé…åˆ—ã«jokerTransform:{suit, rank}ã‚’åŠ ãˆã¦ã‚µãƒ¼ãƒé€ä¿¡

ã‚µãƒ¼ãƒã‚‚JOKERã®å¤‰èº«å…ˆã‚’å¿…ãšå‚ç…§ã—å½¹åˆ¤å®š

éšæ®µé©å‘½ç™ºå‹•ã¯isValidStairså†…ã§ã€Œ4æšä»¥ä¸Šã®éšæ®µã€ã§é©å‘½ONåˆ¤å®šã‚’è¿½åŠ 

â— ã‚µãƒ¼ãƒã®JOKERå¯¾å¿œ
handlePlayã§jokerTransformæƒ…å ±ã‚’å—ã‘å–ã‚Šã€ãã‚Œã§éšæ®µã‚„8åˆ‡ã‚Š/7æ¸¡ã—/é©å‘½ã®åˆ¤å®šã‚‚ä¸€è‡´ã™ã‚‹ã‚ˆã†ã«

å¤‰èº«å…ˆãŒ8/7ãªã‚‰ä¸¡ãƒ«ãƒ¼ãƒ«ç™ºå‹•

â— Jãƒãƒƒã‚¯ï¼‹é©å‘½ç«¶åˆãƒ­ã‚¸ãƒƒã‚¯
é©å‘½æ™‚ã«Jãƒãƒƒã‚¯ç™ºå‹•â†’1ã‚¿ãƒ¼ãƒ³ã ã‘é€šå¸¸é †â†’æ¬¡ã‚¿ãƒ¼ãƒ³ã§å†ã³é©å‘½

çŠ¶æ…‹ãƒ•ãƒ©ã‚°jBackActiveã¨revolutionã®åˆ¤å®šå„ªå…ˆé †ä½ãƒ»æ¶ˆå»ã‚¿ã‚¤ãƒŸãƒ³ã‚°ã‚’æ˜ç¢ºåŒ–

ã‚·ãƒ¼ã‚±ãƒ³ã‚¹å›³ã‚‚ä¸€æ™‚çš„ãªçŠ¶æ…‹é·ç§»ãŒè¦‹ãˆã‚‹ã‚ˆã†ä¿®æ­£

â— éšæ®µã§ã®é©å‘½åˆ¤å®š
éšæ®µå‡ºã—æ™‚ï¼ˆisMoveStairs=trueã‹ã¤length>=4ï¼‰ã§ã‚‚é©å‘½ãƒ•ãƒ©ã‚°ONã«

ğŸ“è‡´å‘½çš„ãƒã‚°ã®æ ¹æœ¬è§£æ±ºã‚¢ãƒ—ãƒ­ãƒ¼ãƒï¼ˆææ¡ˆï¼‰
1. ã‚¿ãƒ¼ãƒ³ãƒ«ãƒ¼ãƒ—ï¼†ä¸ŠãŒã‚Šãƒã‚°ã®è§£æ±ºç­–

getNextAlive()ãƒ»ã‚¿ãƒ¼ãƒ³ç®¡ç†å¼·åŒ–

æ¯ã‚¿ãƒ¼ãƒ³çµ‚äº†æ™‚ã€finishedãƒ•ãƒ©ã‚°ãŒtrueãªã‚‰ã‚¹ã‚­ãƒƒãƒ—ã™ã‚‹whileãƒ«ãƒ¼ãƒ—å¾¹åº•

handlePlay/handlePass/å…¨ãƒ«ãƒ¼ãƒˆã§ã‚¿ãƒ¼ãƒ³é·ç§»å¾Œã«å³ã€Œæ¬¡ã®ç”Ÿãã¦ã‚‹ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã€ã¸ã‚¸ãƒ£ãƒ³ãƒ—

isGameOverã¯ã€Œfinished=falseã€ã®äººæ•°åˆ¤å®šã§åˆ†å²

å‹ã¡æŠœã‘äººæ•°ãŒå¢—ãˆãŸç¬é–“ã€é †ä½ã¨finishedã‚’å¿…ãšæ›´æ–°



2. JOKERå¤‰èº«UI/éšæ®µJOKERã®å®Ÿè£…
Aæ¡ˆï¼ˆæ¨™æº–çš„ï¼‰
ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆ

playSelectedã§éšæ®µï¼‹JOKERæ¤œå‡ºæ™‚ã€ã‚µãƒ¼ãƒã«JOKERå¤‰èº«å…ˆã‚‚ä¼ãˆã‚‹

JOKERå¤‰èº«å…ˆã‚’æŒ‡å®šã—ãªã‘ã‚Œã°ãƒ—ãƒ¬ã‚¤ä¸å¯ã«

ã‚µãƒ¼ãƒ

handlePlayã§JOKERå¤‰èº«å…ˆãŒå¿…é ˆã«ãªã‚‹å ´åˆã¯ãã‚Œã‚’å‚ç…§ã—ã¦åˆ¤å®š


3. éšæ®µã§ã®é©å‘½ãƒ­ã‚¸ãƒƒã‚¯
Aæ¡ˆï¼ˆæœ€ã‚‚ä¸€èˆ¬çš„ï¼‰
éšæ®µå½¹åˆ¤å®šisMoveStairså†…ã§ã€4æšä»¥ä¸Šéšæ®µï¼é©å‘½ã®åˆ¤å®šãƒ­ã‚¸ãƒƒã‚¯è¿½åŠ 

é©å‘½ä¸­ã«å†ã³4æšéšæ®µã§ã€Œé©å‘½è¿”ã—ã€



ã€å…¨ä½“è¨­è¨ˆã€‘æ”¹ä¿®ç²’åº¦ãƒ»ä»Šå¾Œã®æ§‹æˆæŒ‡é‡
ã‚µãƒ¼ãƒ/ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆåŒæ–¹ã§çŠ¶æ…‹é·ç§»ã‚’çµ±ä¸€

å„ãƒ«ãƒ¼ãƒ«ã”ã¨ã®å„ªå…ˆé †ä½ã‚’è¡¨ãƒ»ã‚³ãƒ¼ãƒ‰ã‚³ãƒ¡ãƒ³ãƒˆã§æ˜ç¤º

éšæ®µ/JOKERå¯¾å¿œã¯UI/ãƒ­ã‚¸ãƒƒã‚¯ä¸¡é¢ã§è¨­è¨ˆ

è¨­è¨ˆæ›¸ã¯UMLç²’åº¦ã§éšæ™‚è¿½è¨˜ï¼ˆç«¶åˆãƒ«ãƒ¼ãƒ«ã€çŠ¶æ…‹é·ç§»å›³ã€ã‚·ãƒ¼ã‚±ãƒ³ã‚¹è©³ç´°ï¼‰

ã€è³ªå•ãƒ»ç¢ºèªã—ãŸã„ç‚¹ã€‘
1.JOKERå¤‰èº«UIã®ä»•æ§˜ï¼š

ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã§ã€Œå¤‰èº«å…ˆã‚«ãƒ¼ãƒ‰ã€ã‚’ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒé¸æŠã™ã‚‹æ–¹å¼ã§OKã‹ï¼Ÿ
ï¼ˆè‡ªå‹•åˆ¤å®š or ãƒ¦ãƒ¼ã‚¶ãƒ¼é¸æŠã‹ã‚’æ±ºã‚ã¦ãã ã•ã„ï¼‰
â†’è‡ªåˆ†ã§æ±ºã‚ã‚‹
2.éšæ®µé©å‘½ã®ãƒˆãƒªã‚¬ãƒ¼ï¼š

4æšä»¥ä¸Šéšæ®µãªã‚‰é©å‘½ã€ã¨ã„ã†ä»•æ§˜ã§è‰¯ã„ã‹ï¼Ÿ
ä¾‹ï¼‰5,6,7,8 ãªã©ã®éšæ®µã§é©å‘½ç™ºå‹•
â†’4æ®µä»¥ä¸Šã§é©å‘½
3.é †ä½ä»˜ã‘ï¼†ä¸ŠãŒã‚ŠæŠœã‘ä»•æ§˜ï¼š

å‹ã¡æŠœã‘é †ã«å¤§å¯Œè±ªã€œå¤§è²§æ°‘ã‚’è‡ªå‹•ä»˜ä¸ã€æœ€å¾Œã¾ã§ç¶šè¡Œã§OKã‹ï¼Ÿ
â†’ãã†ã€ä¾‹:5äººå¯¾æˆ¦ãªã‚‰ãã‚Œã«åŠ ãˆã¦å¤§å¯Œè±ªã€å¯Œè±ªã€å¹³æ°‘ã€è²§æ°‘ã€å¤§è²§æ°‘
ãã‚Œãã‚Œã«+2,+1,0,-1,-2ç‚¹ã‚’ä»˜ä¸(4äººå¯¾æˆ¦ãªã‚‰ã“ã“ã‹ã‚‰å¹³æ°‘ãŒæ¶ˆãˆã‚‹.3äººãªã‚‰å¯Œè±ª,å¹³æ°‘,è²§æ°‘.2äººå¯¾æˆ¦ãªã‚‰å¯Œè±ª,è²§æ°‘)
æœ€å¾ŒãŒä½•ã‹ã¯ä½•ã‚²ãƒ¼ãƒ åˆ¶ã«ã™ã‚‹ã®ã‹ã‚’ãƒ«ãƒ¼ãƒ ä½œæˆæ™‚ç‚¹ã§æ±ºã‚ã‚‰ã‚Œã‚‹ã‚ˆã†ã«ã™ã‚‹
4.Jãƒãƒƒã‚¯ï¼‹é©å‘½ç«¶åˆã¯

ã€ŒJãƒãƒƒã‚¯æ™‚ã ã‘ä¸€æ™‚çš„ã«é€šå¸¸é †ã€æ¬¡ã‚¿ãƒ¼ãƒ³ã§é©å‘½é †å¾©å¸°ã€ã§OKã‹
â†’é©å‘½æ™‚ã«jãƒãƒƒã‚¯ç™ºå‹•ã®éš›ã¯ã€ä¸€æ™‚çš„ã«é€šå¸¸é †ã§ã™
ã—ã‹ã—ã“ã‚Œã¯ã‚‚ã†æ²»ã£ã¦ã„ã‚‹ã¨æ€ã„ã¾ã™






ğŸŸ¡ ä»Šå¾Œè¿½åŠ ã™ã¹ãæ®‹ã‚Šæ©Ÿèƒ½ï¼ˆè¨­è¨ˆæ›¸ï¼ã‚¯ãƒ©ã‚¹å›³ã®è¦³ç‚¹ã‹ã‚‰ï¼‰
æ©Ÿèƒ½	å†…å®¹	çŠ¶æ…‹	å‚™è€ƒ
ğŸ” ã‚²ãƒ¼ãƒ ãƒªã‚»ãƒƒãƒˆæ©Ÿèƒ½	å‹è€…æ±ºå®šå¾Œã€2ã‚²ãƒ¼ãƒ ç›®ã‚’é–‹å§‹ã§ãã‚‹ä»•çµ„ã¿	æœªå®Ÿè£…	GameRoom ã‚’å†åˆ©ç”¨ã§ãã‚‹ã‚ˆã†ã«ã™ã‚‹å¿…è¦ã‚ã‚Š
ğŸ§  NPCã®ç°¡æ˜“ãƒ­ã‚¸ãƒƒã‚¯	NPCãŒè‡ªå‹•ã§ã‚«ãƒ¼ãƒ‰ã‚’å‡ºã™ or ãƒ‘ã‚¹ã™ã‚‹	æœªå®Ÿè£…	ç¾åœ¨NPCã¯ä½•ã‚‚è¡Œå‹•ã—ãªã„
â™»ï¸ å†æ¥ç¶šå‡¦ç†	æ¥ç¶šãŒåˆ‡ã‚ŒãŸãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒå¾©å¸°ã§ãã‚‹	æœªå®Ÿè£…	WebSocketåˆ‡æ–­å¾Œã®å‡¦ç†æ‹¡å¼µãŒå¿…è¦
ğŸ“ è¦³æˆ¦ãƒ¢ãƒ¼ãƒ‰	è¦³æˆ¦ã®ã¿ã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ï¼ˆisSpectatorï¼‰	ä»»æ„	UMLã«ã‚ã‚Œã°ã ãŒä»Šã¯å„ªå…ˆåº¦ä½
ğŸ§© ãƒ­ãƒ¼ã‚«ãƒ«ãƒ«ãƒ¼ãƒ«ã®å°å…¥	8åˆ‡ã‚Šãƒ»é©å‘½ãªã©å¤§å¯Œè±ªãƒ«ãƒ¼ãƒ«	ä»»æ„	ã‚¹ãƒ†ãƒƒãƒ—ã‚¢ãƒƒãƒ—é …ç›®ï¼ˆä»Šã¯ã‚·ãƒ³ãƒ—ãƒ«ä»•æ§˜ï¼‰
ğŸ§‘â€ğŸ¤â€ğŸ§‘ UIã®æ”¹å–„	ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ã‚¿ãƒ¼ãƒ³è¡¨ç¤ºãƒ»æ®‹ã‚Šæ‰‹æœ­æšæ•°ãªã©	ä¸€éƒ¨æ¸ˆ	æ”¹å–„ä½™åœ°ã‚ã‚Šï¼ˆã‚ˆã‚Šè¦–è¦šçš„ã«ï¼‰
ğŸ§ª ãƒ†ã‚¹ãƒˆå°å…¥	å˜ä½“ãƒ†ã‚¹ãƒˆãƒ»ã‚·ãƒŠãƒªã‚ªãƒ†ã‚¹ãƒˆ	æœªç€æ‰‹	æœ¬æ ¼é–‹ç™ºã§ã¯å¿…è¦ã«ãªã‚‹å·¥ç¨‹


ğŸ” ã‚²ãƒ¼ãƒ å†ã‚¹ã‚¿ãƒ¼ãƒˆæ©Ÿèƒ½
ã€€â†’ ã‚²ãƒ¼ãƒ çµ‚äº†å¾Œã«æ–°ã—ã„ã‚²ãƒ¼ãƒ ã‚’åŒã˜ãƒ«ãƒ¼ãƒ ã§å§‹ã‚ã‚‰ã‚Œã‚‹ã‚ˆã†ã«ã™ã‚‹ã€‚
ã€€â†’ resetGame() ãªã©ã‚’ GameRoom ã«è¿½åŠ ã€clientå´ã«ã€Œå†ã‚¹ã‚¿ãƒ¼ãƒˆã€ãƒœã‚¿ãƒ³å®Ÿè£…ã€‚

å‰å›gptã®ãƒ¡ãƒ¢ä»¥ä¸‹(ã“ã‚Œã¯é–“é•ã£ã¦ã„ã‚‹éƒ¨åˆ†ã‚‚ã‚ã‚‹å¯èƒ½æ€§ãŒã‚ã‚‹ã“ã¨ã«ç•™æ„ã—ã¦ãã ã•ã„)
âœ… æ§‹ç¯‰ç’°å¢ƒï¼ˆãƒ­ãƒ¼ã‚«ãƒ«é–‹ç™ºç’°å¢ƒï¼‰
é …ç›®	å†…å®¹
OS	Windowsï¼ˆCode Page: 65001 / UTF-8ï¼‰
å®Ÿè¡Œç’°å¢ƒ	Node.js (server.js ã«ã‚ˆã‚‹WebSocketã‚µãƒ¼ãƒãƒ¼)
ä½¿ç”¨ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸	express, ws
ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªæ§‹æˆ	C:\dgf-online\ é…ä¸‹ã«ä»¥ä¸‹ãŒå­˜åœ¨ï¼š
â”œâ”€ server/ â†’ server.js, GameRoom.js
â””â”€ public/ â†’ client.js, index.html ãªã©
èµ·å‹•æ–¹æ³•	node server/server.js ã«ã¦ãƒ­ãƒ¼ã‚«ãƒ«ã‚µãƒ¼ãƒãƒ¼èµ·å‹•
ãƒãƒ¼ãƒˆ	http://localhost:3000 ã§æ¥ç¶šç¢ºèªæ¸ˆã¿
ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆé€šä¿¡	WebSocketï¼ˆws://localhost:3000ï¼‰ã§ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ é€šä¿¡
å®Ÿè¡Œãƒ­ã‚°	ã‚µãƒ¼ãƒãƒ¼èµ·å‹• http://localhost:3000 ç¢ºèªæ¸ˆã¿
ãƒ–ãƒ©ã‚¦ã‚¶å‹•ä½œ	ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆç”»é¢è¡¨ç¤ºãƒ»ã‚²ãƒ¼ãƒ é–‹å§‹å¯èƒ½ï¼ˆé€šä¿¡ã¯å‹•ä½œï¼‰

ğŸ“Œ ç¾çŠ¶ã®é€²æ—ã¨èª²é¡Œ
ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹	å†…å®¹
âœ… ã‚²ãƒ¼ãƒ ãƒ«ãƒ¼ãƒ ä½œæˆ	ä¸»å‚¬è€…ãŒéƒ¨å±‹ã‚’ä½œæˆã—ã€æœ€å¤§äººæ•°è¨­å®šå¯èƒ½
âœ… ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼å‚åŠ 	ä»–ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒå‚åŠ ã€‚äººæ•°ä¸è¶³æ™‚ã¯ NPC è‡ªå‹•è£œå……
âœ… ã‚²ãƒ¼ãƒ é–‹å§‹å‡¦ç†	ã€Œã‚¹ã‚¿ãƒ¼ãƒˆãƒœã‚¿ãƒ³ã€æŠ¼ä¸‹ã§å…¨ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã«æ‰‹æœ­é…å¸ƒ
âœ… æ‰‹æœ­è¡¨ç¤º	ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆå´ã«ã‚«ãƒ¼ãƒ‰ãŒãƒœã‚¿ãƒ³å½¢å¼ã§è¡¨ç¤ºã•ã‚Œã‚‹
âœ… å‹åˆ©åˆ¤å®š	ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®æ‰‹æœ­ãŒç©ºã«ãªã£ãŸã‚‰å‹åˆ©ã¨åˆ¤å®šã—ã€game-ended ã‚’é€ä¿¡
âš ï¸ æœªç¢ºèªã¾ãŸã¯ä¸å®‰å®š	ä»¥ä¸‹ã®æŒ™å‹•ãŒã¾ã æ¤œè¨¼ãƒ»èª¿æ•´ä¸­ï¼š
ãƒ»ã‚¿ãƒ¼ãƒ³çµ‚äº†å¾Œã€æ¬¡ã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã® your-turn ãŒæ­£ã—ãå±Šã‹ãªã„å ´åˆãŒã‚ã‚‹
ãƒ»ä»–ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã«ã‚«ãƒ¼ãƒ‰å‡ºã—ãŒåæ˜ ã•ã‚Œãªã„ã“ã¨ãŒã‚ã‚‹
ãƒ»NPCã®è‡ªå‹•ã‚¿ãƒ¼ãƒ³å‡¦ç†ã¯æœªå®Ÿè£…ï¼ˆç¾çŠ¶ã§ã¯å¾…ã¡ã®ã¾ã¾ï¼‰

ğŸ¯ æ¬¡ã«å®Ÿè£…ãƒ»ç¢ºèªã™ã¹ãé …ç›®ï¼ˆç›®å®‰ï¼‰
 å‡ºã—ãŸã‚«ãƒ¼ãƒ‰ãŒä»–ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ç”»é¢ã«ã‚‚æ­£ã—ãåæ˜ ã•ã‚Œã‚‹ã‹ç¢ºèª

 ã‚¿ãƒ¼ãƒ³ãŒå¾ªç’°ã™ã‚‹ã‚ˆã†ã« your-turn é€šçŸ¥ãŒé€£æºã—ã¦ã„ã‚‹ã‹ãƒ†ã‚¹ãƒˆ

 NPCã®è‡ªå‹•ã‚«ãƒ¼ãƒ‰å‡ºã—ï¼ˆAIãƒ­ã‚¸ãƒƒã‚¯ or ãƒ©ãƒ³ãƒ€ãƒ ï¼‰å®Ÿè£…ï¼ˆå¿…è¦ã«å¿œã˜ã¦ï¼‰

 UIãƒªã‚»ãƒƒãƒˆï¼2ã‚²ãƒ¼ãƒ ç›®ä»¥é™ã®å‡¦ç†ç¢ºèª

ğŸ§­ å¼•ãç¶™ãã®ãŸã‚ã®ä¸€è¨€ãƒ¡ãƒ¢ï¼ˆãƒ†ãƒ³ãƒ—ãƒ¬ï¼‰
ã“ã®ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã¯ Node.js + WebSocket ã‚’ç”¨ã„ãŸã€Œå¤§å¯Œè±ªã‚ªãƒ³ãƒ©ã‚¤ãƒ³ã‚²ãƒ¼ãƒ ã€ã§ã™ã€‚
ç¾æ™‚ç‚¹ã§ã‚²ãƒ¼ãƒ ã‚¹ã‚¿ãƒ¼ãƒˆã€œå‹åˆ©åˆ¤å®šã¾ã§ã¯ä¸€é€šã‚Šé€šã£ã¦ãŠã‚Šã€æ®‹ã‚‹èª²é¡Œã¯ã‚¿ãƒ¼ãƒ³åŒæœŸã¨ä»–ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã¸ã®ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ åæ˜ ã§ã™ã€‚
NPCã®ãƒ­ã‚¸ãƒƒã‚¯ã‚„å†è©¦åˆæ©Ÿèƒ½ã¯å¾Œå›ã—ã§ã€ã¾ãšã¯1ã‚²ãƒ¼ãƒ ãŒã‚¹ãƒ ãƒ¼ã‚ºã«é€²è¡Œã™ã‚‹ã“ã¨ã‚’å„ªå…ˆã—ã¦ã„ã¾ã™ã€‚





ä»¥ä¸‹ã‚³ãƒ¼ãƒ‰
public/client.js


// =================================
//  client.js  â€• ä¸ƒæ¸¡ã—å®Œå…¨UIãƒ»ãƒã‚°é˜²æ­¢å¯¾å¿œ + å†—é•·æ€§
// =================================
let ws, playerName, roomId;

// --------- DOM ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ ---------
const $ = id => document.getElementById(id);

// --------- WebSocket æ¥ç¶š ---------
function connect() {
  const proto = location.protocol === 'https:' ? 'wss' : 'ws';
  ws = new WebSocket(`${proto}://${location.host}`);
  ws.onopen = () => ws.send(JSON.stringify({ type: 'join', room: roomId, name: playerName }));
  ws.onmessage = e => handle(JSON.parse(e.data));
  ws.onclose = () => setTimeout(connect, 1000);
}

// --------- åˆæœŸåŒ– ---------
window.onload = () => {
  const p = new URLSearchParams(location.search);
  playerName = p.get('name'); roomId = p.get('room');
  if (!playerName || !roomId) { location = 'index.html'; return; }
  $('roomLabel').textContent = `ãƒ«ãƒ¼ãƒ : ${roomId}`;
  connect();

  $('startBtn').onclick = () => ws.send(JSON.stringify({ type: 'start' }));
  $('resetBtn').onclick = () => ws.send(JSON.stringify({ type: 'reset' }));
  $('quitBtn').onclick = () => location = 'index.html';
  $('playBtn').onclick = playSelected;
  $('passBtn').onclick = () => ws.send(JSON.stringify({ type: 'pass' }));

  // ğŸŸ¦ ä¸ƒæ¸¡ã—UI
  if ($('sevenSection')) {
    $('sevenGiveBtn').onclick = sendSevenCard;
    $('sevenSection').style.display = 'none';
  }
};

function playSelected() {
  const sel = [...document.querySelectorAll('.card.selected')];
  if (sel.length === 0) return;
  const data = sel.map(b => ({ suit: b.dataset.suit, rank: b.dataset.rank }));
  ws.send(JSON.stringify({ type: 'play', cards: data }));
  sel.forEach(b => b.classList.remove('selected'));
}

// ğŸŸ¦ ä¸ƒæ¸¡ã—: å¿…è¦ãªæšæ•°ã ã‘é¸æŠã—ä¸€æ‹¬é€ä¿¡
function sendSevenCard() {
  const sel = [...document.querySelectorAll('.card.selected')];
  const n = parseInt($('sevenSection').dataset.needcount, 10) || 1;
  if (sel.length !== n) return;
  const cards = sel.map(b => ({ suit: b.dataset.suit, rank: b.dataset.rank }));
  ws.send(JSON.stringify({ type: 'seven-give', cards }));
  sel.forEach(b => b.classList.remove('selected'));
  $('sevenSection').style.display = 'none';
}

// --------- å—ä¿¡ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã§ç”»é¢æ›´æ–° ---------
function handle(state) {
  // ===== ã‚²ãƒ¼ãƒ çµ‚äº†ç”»é¢ =====
  if (state.type === 'final') {
    $('playersList').innerHTML = '';
    $('fieldCards').textContent = '';
    $('handSection').style.display = 'none';
    $('sevenSection').style.display = 'none';
    $('statusMsg').textContent = 'ã‚²ãƒ¼ãƒ çµ‚äº†';
    const res = $('result'); res.innerHTML = '<h3>çµæœ</h3>';
    state.ranking.forEach(r => {
      const div = document.createElement('div');
      div.textContent = `${r.title}: ${r.name}ã•ã‚“`;
      res.appendChild(div);
    });
    $('resetBtn').style.display = (state.players[0].name === playerName) ? 'inline-block' : 'none';
    $('quitBtn').style.display = (state.players[0].name === playerName) ? 'inline-block' : 'none';
    $('startBtn').style.display = 'none';
    return;
  }

  if (!state.started) {
    $('startBtn').style.display =
      state.players.length >= 1 && state.players[0].name === playerName ? 'inline-block' : 'none';
    $('resetBtn').style.display = 'none'; $('quitBtn').style.display = 'none';

    $('playersList').innerHTML = state.players.map(p =>
      `<div>${p.name}ã•ã‚“ï¼ˆå…¥å®¤ä¸­ï¼‰</div>`).join('');
    $('fieldCards').textContent = 'ï¼ˆã‚²ãƒ¼ãƒ å¾…æ©Ÿä¸­ï¼‰';
    $('handSection').style.display = 'none';
    $('sevenSection').style.display = 'none';
    $('result').innerHTML = ''; $('statusMsg').textContent = '';
    return;
  }

  // ğŸŸ¦ ä¸ƒæ¸¡ã—UIè¡¨ç¤ºï¼ˆå¿…è¦ãªæšæ•°åˆ†ã ã‘ã‚«ãƒ¼ãƒ‰ã‚’é¸ã°ã›ã‚‹ï¼‰
  if (state.waitingForSevenCard && state.waitingForSevenCardPlayer === playerName) {
    $('sevenSection').style.display = 'block';
    $('sevenSection').dataset.needcount = state.needSevenCount || 1;
    $('sevenSection').querySelector('.seven-desc').textContent =
      `7æ¸¡ã—: æ‰‹æœ­ã‹ã‚‰${state.needSevenCount || 1}æšé¸ã‚“ã§ã€Œæ¸¡ã™ã€ã‚’æŠ¼ã—ã¦ãã ã•ã„`;
  } else {
    if ($('sevenSection')) $('sevenSection').style.display = 'none';
  }

  $('startBtn').style.display = 'none';
  $('resetBtn').style.display = 'none';
  $('quitBtn').style.display = 'none';

  $('playersList').innerHTML = state.players.map(p => {
    const cur = p.name === state.currentTurn ? ' style="background:#ffef99"' : '';
    const me = p.name === playerName ? ' style="font-weight:bold"' : '';
    const sty = cur || me;
    const txt = p.finished ? `${p.name}ã•ã‚“ - ä¸ŠãŒã‚Š`
      : `${p.name}ã•ã‚“ - ${p.cardsCount}æš`;
    return `<div${sty}>${txt}</div>`;
  }).join('');

  $('fieldCards').textContent =
    state.field.cards.length ? `å ´: [${state.field.cards.join(', ')}]` : 'å ´: ï¼ˆãªã—ï¼‰';

  const hc = $('handCards'); hc.innerHTML = '';
  state.yourHand.forEach(s => {
    const b = document.createElement('button'); b.className = 'card'; b.textContent = s;
    if (s === 'Joker') { b.dataset.suit = 'J'; b.dataset.rank = '16'; }
    else { b.dataset.suit = s[0]; b.dataset.rank = s.slice(1); }
    b.onclick = () => b.classList.toggle('selected');
    hc.appendChild(b);
  });
  $('handSection').style.display = 'block';

  const myTurn = state.currentTurn === playerName;
  $('playBtn').disabled = !myTurn || (state.waitingForSevenCard && state.waitingForSevenCardPlayer === playerName);
  $('passBtn').disabled = !myTurn || state.field.cards.length === 0 || (state.waitingForSevenCard && state.waitingForSevenCardPlayer === playerName);

  if (state.waitingForSevenCard && state.waitingForSevenCardPlayer === playerName) {
    $('playBtn').disabled = true;
    $('passBtn').disabled = true;
  }

  $('statusMsg').textContent = state.revolution ? 'é©å‘½ç™ºç”Ÿä¸­!' : '';
  $('lastAction').textContent = state.lastMove ?
    (state.lastMove.move === 'pass'
      ? `${state.lastMove.player}ã•ã‚“ãŒãƒ‘ã‚¹ã—ã¾ã—ãŸ`
      : `${state.lastMove.player}ã•ã‚“ãŒ ${state.lastMove.cards.join(', ')} ã‚’å‡ºã—ã¾ã—ãŸ`
      + (state.lastMove.special ? ` (${state.lastMove.special})` : '')) : '';
}










public/game.html









<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8" />
    <title>å¤§å¯Œè±ªã‚ªãƒ³ãƒ©ã‚¤ãƒ³ - ã‚²ãƒ¼ãƒ </title>
    <link rel="stylesheet" href="style.css" />
</head>

<body>
    <h1>å¤§å¯Œè±ªã‚ªãƒ³ãƒ©ã‚¤ãƒ³</h1>
    <div id="roomLabel"></div>
    <div id="playersList" class="players-list"></div>
    <div id="fieldCards" class="field"></div>
    <div id="statusMsg" class="status-msg"></div>
    <div id="lastAction" class="last-action"></div>

    <div id="handSection">
        <h2 id="handTitle"></h2>
        <div id="handCards" class="hand-cards"></div>
        <div class="controls">
            <button id="playBtn">å‡ºã™</button>
            <button id="passBtn">ãƒ‘ã‚¹</button>
        </div>
    </div>
    <!-- ä¸ƒæ¸¡ã—UIã‚»ã‚¯ã‚·ãƒ§ãƒ³ -->
    <div id="sevenSection" style="display:none;">
        <div class="seven-desc" style="margin:10px 0; color:#c00; font-weight:bold;">
            7æ¸¡ã—: æ‰‹æœ­ã‹ã‚‰1æšé¸ã‚“ã§ã€Œæ¸¡ã™ã€ã‚’æŠ¼ã—ã¦ãã ã•ã„
        </div>
        <button id="sevenGiveBtn">æ¸¡ã™</button>
    </div>
    <div id="result" class="result"></div>
    <button id="startBtn" class="start-btn">ã‚²ãƒ¼ãƒ é–‹å§‹</button>
    <button id="resetBtn" class="reset-btn">å†æˆ¦</button>
    <button id="quitBtn" class="reset-btn">ãƒ«ãƒ¼ãƒ è§£æ•£</button>
    <script src="client.js"></script>
</body>

</html>














public/index.html











<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8" />
    <title>å¤§å¯Œè±ªã‚ªãƒ³ãƒ©ã‚¤ãƒ³ - å…¥å®¤</title>
    <link rel="stylesheet" href="style.css" />
</head>

<body>
    <h1>å¤§å¯Œè±ªã‚ªãƒ³ãƒ©ã‚¤ãƒ³ ã‚²ãƒ¼ãƒ </h1>
    <div class="form-container">
        <form id="joinForm" action="game.html" method="GET">
            <label>ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼å: <input type="text" name="name" required /></label><br />
            <label>ãƒ«ãƒ¼ãƒ ID: <input type="text" name="room" required /></label><br />
            <button type="submit">å…¥å®¤</button>
        </form>
    </div>
</body>

</html>














style.css














body {
    font-family: sans-serif;
    margin: 20px;
}

h1 {
    margin-bottom: 10px;
}

.form-container {
    margin-top: 20px;
}

.players-list {
    margin: 10px 0;
    padding: 10px;
    border: 1px solid #333;
    max-width: 300px;
}

.players-list .current-turn {
    background-color: #ffef99;
}

.field {
    font-weight: bold;
    margin: 10px 0;
}

.status-msg {
    margin: 5px 0;
    font-weight: bold;
}

.last-action {
    margin: 5px 0;
    font-style: italic;
}

#handSection {
    margin: 15px 0;
}

.hand-cards {
    margin: 5px 0;
}

.hand-cards .card {
    margin: 2px;
    padding: 5px 8px;
    cursor: pointer;
}

.hand-cards .card.selected {
    background-color: #aed;
}

.controls {
    margin: 5px 0;
}

.controls button {
    margin-right: 10px;
}

.start-btn,
.reset-btn {
    display: none;
    /* å¿…è¦ãªæ™‚ã«è¡¨ç¤º */
    margin-top: 15px;
    padding: 5px 10px;
}

.result {
    margin-top: 15px;
    padding: 10px;
    border: 1px solid #555;
    max-width: 300px;
    background-color: #f9f9f9;
}














server/GameRoom.js














// ====================================
//  GameRoom.js  â€• ä¸ƒæ¸¡ã—ãƒ»é©å‘½ãƒ»Jãƒãƒƒã‚¯ãƒã‚°å®Œå…¨ä¿®æ­£ï¼ˆå†—é•·ãƒ»çœç•¥ã‚¼ãƒ­ï¼‰
// ====================================

class Card {
    constructor(suit, rank) {
        this.suit = suit;
        this.rank = rank;
        this.isJoker = suit === 'J';
    }
    toString() {
        return this.isJoker ? 'Joker' : this.suit + Card.rankToLabel(this.rank);
    }
    static rankToLabel(r) {
        return { 11: 'J', 12: 'Q', 13: 'K', 14: 'A', 15: '2' }[r] || String(r);
    }
}

class Deck {
    constructor(useJoker = true) {
        this.cards = [];
        const suits = ['â™£', 'â™¦', 'â™¥', 'â™ '];
        const ranks = [3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15];
        for (const s of suits) for (const r of ranks) this.cards.push(new Card(s, r));
        if (useJoker) this.cards.push(new Card('J', 16));
    }
    shuffle() {
        for (let i = this.cards.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [this.cards[i], this.cards[j]] = [this.cards[j], this.cards[i]];
        }
    }
}

class Player {
    constructor(name, conn = null, isNPC = false) {
        this.name = name;
        this.conn = conn;
        this.connected = !!conn;
        this.isNPC = isNPC;
        this.hand = [];
        this.finished = false;
        this.rankTitle = '';
    }
}

class GameRoom {
    constructor(roomId) {
        this.roomId = roomId;
        this.players = [];
        this.started = false;
        this.currentTurn = 0;
        this.jBackActive = false;
        this.lastPlayedCards = [];
        this.lastPlayedRank = null;
        this.lastPlayedCount = 0;
        this.lastPlayerIndex = null;
        this.passCount = 0;
        this.revolution = false;
        this.lastChampion = null;
        this.lastMoveInfo = null;
        this._deleteTimer = null;
        this.spade3BackPending = false;
        this.lastPlayWasStairs = false;
        this.waitingForSevenCard = false;
        this.waitingForSevenCardPlayer = null;
        this.needSevenCount = 1;
    }

    getPlayer(name) { return this.players.find(p => p.name === name); }

    addPlayer(name, conn) {
        const exist = this.getPlayer(name);
        if (exist) {
            if (exist.connected) return { ok: false, error: 'åŒåãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒæ—¢ã«æ¥ç¶šä¸­ã§ã™ã€‚' };
            exist.conn = conn; exist.connected = true; exist.isNPC = false;
            return { ok: true, reconnect: true };
        }
        this.players.push(new Player(name, conn, false));
        return { ok: true, reconnect: false };
    }

    fillNPCPlayers() {
        while (this.players.length < 4) {
            const npcName = `NPC${this.players.length}`;
            if (!this.getPlayer(npcName)) this.players.push(new Player(npcName, null, true));
        }
    }

    startGame() {
        this.started = true;
        this.revolution = false;
        this.lastPlayedCards = []; this.lastPlayedRank = null; this.lastPlayedCount = 0;
        this.lastPlayerIndex = null; this.passCount = 0; this.lastMoveInfo = null;
        this.jBackActive = false;
        this.spade3BackPending = false;
        this.lastPlayWasStairs = false;
        this.waitingForSevenCard = false;
        this.waitingForSevenCardPlayer = null;
        this.needSevenCount = 1;

        this.players.forEach(p => { p.hand = []; p.finished = false; p.rankTitle = ''; });
        this.fillNPCPlayers();

        const deck = new Deck(true); deck.shuffle();
        let idx = 0; for (const c of deck.cards) { this.players[idx].hand.push(c); idx = (idx + 1) % this.players.length; }
        this.players.forEach(p => p.hand.sort((a, b) => a.rank - b.rank));
        this.currentTurn = 0;
        this.broadcastState();
        this.checkAndHandleNPC();
    }

    getNextAlive(idx) {
        const n = this.players.length;
        let i = idx;
        do { i = (i + 1) % n; } while (this.players[i].finished);
        return i;
    }

    rankValue(card) { return card.isJoker ? 16 : card.rank; }

    isValidStairs(cards) {
        if (cards.length < 3) return false;
        const suit = cards[0].suit;
        if (!cards.every(c => c.suit === suit && !c.isJoker)) return false;
        const sorted = [...cards].sort((a, b) => a.rank - b.rank);
        for (let i = 1; i < sorted.length; i++) {
            if (sorted[i].rank !== sorted[i - 1].rank + 1) return false;
        }
        return true;
    }

    prevIsStairs() {
        return (this.lastPlayedCards.length >= 3 && this.isValidStairs(this.lastPlayedCards));
    }

    isMoveStairs(cards) {
        return (cards.length >= 3 && this.isValidStairs(cards));
    }

    isRevJBack() {
        return this.revolution && this.jBackActive;
    }

    isJBackOK(cards) {
        if (this.isRevJBack()) {
            return cards.every(c => (!c.isJoker && c.rank >= 12) || c.isJoker);
        } else {
            return cards.every(c => !c.isJoker && c.rank <= 11);
        }
    }

    // é©å‘½åˆ¤å®šï¼šã€Œ4æšä»¥ä¸ŠåŒä¸€ãƒ©ãƒ³ã‚¯å½¹ã€ã‹ã¤ã€Œéšæ®µå½¹ã¯é™¤å¤–ã€ï¼ˆå†—é•·æ˜ç¤ºï¼‰
    _mostCommonRank(cards) {
        const ranks = {};
        cards.forEach(c => {
            if (c.isJoker) return;
            ranks[c.rank] = (ranks[c.rank] || 0) + 1;
        });
        let max = 0, maxRank = null;
        for (const r in ranks) {
            if (ranks[r] > max) { max = ranks[r]; maxRank = parseInt(r); }
        }
        return maxRank;
    }
    isRevolutionCombo(played) {
        if (played.length < 4) return false;
        if (this.isMoveStairs(played)) return false; // 4æšä»¥ä¸Šéšæ®µã¯é©å‘½ã¨ãªã‚‰ãªã„
        const mainRank = this._mostCommonRank(played);
        if (mainRank === null) return false;
        let sameCount = played.filter(c => c.rank === mainRank || c.isJoker).length;
        return sameCount === played.length;
    }

    getPlayableGroups(hand) {
        let groups = [];
        const prevIsStairs = this.prevIsStairs();
        const lastCount = this.lastPlayedCount || 1;
        const lastRank = this.lastPlayedRank;
        const isJBack = this.jBackActive;
        const isRev = this.revolution;

        if (prevIsStairs) {
            for (let s of ['â™£', 'â™¦', 'â™¥', 'â™ ']) {
                let suitCards = hand.filter(c => c.suit === s && !c.isJoker).map(c => c.rank).sort((a, b) => a - b);
                for (let i = 0; i <= suitCards.length - lastCount; i++) {
                    let ok = true;
                    for (let j = 1; j < lastCount; j++) {
                        if (suitCards[i + j] !== suitCards[i] + j) { ok = false; break; }
                    }
                    if (ok) {
                        let seq = [];
                        for (let j = 0; j < lastCount; j++) {
                            seq.push(hand.find(c => c.suit === s && c.rank === suitCards[i] + j));
                        }
                        const prev = this.lastPlayedCards.map(c => c.rank).sort((a, b) => a - b)[0];
                        const curr = suitCards[i];
                        if (!isRev) {
                            if (curr > prev) groups.push(seq);
                        } else {
                            if (curr < prev) groups.push(seq);
                        }
                    }
                }
            }
            return groups;
        }
        let validCards = [];
        if (isJBack) {
            if (this.isRevJBack()) {
                validCards = hand.filter(c => (!c.isJoker && c.rank >= 12) || c.isJoker);
            } else {
                validCards = hand.filter(c => !c.isJoker && c.rank <= 11);
            }
        } else {
            validCards = hand.slice();
        }
        let group = {};
        for (let c of validCards) {
            if (!group[c.rank]) group[c.rank] = [];
            group[c.rank].push(c);
        }
        [lastCount].forEach(needCount => {
            Object.values(group).forEach(cards => {
                if (cards.length >= needCount) {
                    groups.push(cards.slice(0, needCount));
                }
            });
        });
        if (!isJBack && !prevIsStairs) {
            const joker = hand.find(c => c.isJoker);
            if (joker && lastCount === 1) {
                if (this.lastPlayedCards.length === 0 || this.rankValue(joker) > lastRank) {
                    groups.push([joker]);
                }
            }
        }
        groups = groups.filter(cards => {
            if (isJBack && !this.isRevJBack()) {
                if (this.lastPlayedCards.length > 0 && !prevIsStairs) {
                    return this.rankValue(cards[0]) < lastRank;
                }
                return true;
            } else if (this.isRevJBack()) {
                if (this.lastPlayedCards.length > 0 && !prevIsStairs) {
                    return this.rankValue(cards[0]) > lastRank;
                }
                return true;
            } else if (isRev) {
                if (this.lastPlayedCards.length > 0 && !prevIsStairs) {
                    return this.rankValue(cards[0]) < lastRank;
                }
                return true;
            } else {
                if (this.lastPlayedCards.length > 0 && !prevIsStairs) {
                    return this.rankValue(cards[0]) > lastRank;
                }
                return true;
            }
        });
        return groups;
    }

    npcAction(pl) {
        if (pl.finished) return;
        if (this.spade3BackPending) {
            const card = pl.hand.find(c => c.suit === 'â™ ' && c.rank === 3);
            if (card) return this.handlePlay(pl.name, [{ suit: 'â™ ', rank: 3 }]);
            else return this.handlePass(pl.name);
        }
        if (this.waitingForSevenCard && this.waitingForSevenCardPlayer === pl.name) {
            for (let i = 0; i < this.needSevenCount; i++) {
                let maxCard = pl.hand[0];
                for (const c of pl.hand) {
                    if (c.rank > maxCard.rank || c.isJoker) maxCard = c;
                }
                pl.hand.splice(pl.hand.indexOf(maxCard), 1);
                let targetIdx = this.getNextAlive(this.currentTurn);
                const target = this.players[targetIdx];
                target.hand.push(maxCard);
                target.hand.sort((a, b) => a.rank - b.rank);
            }
            this.waitingForSevenCard = false;
            this.waitingForSevenCardPlayer = null;
            this.needSevenCount = 1;
            this.currentTurn = this.getNextAlive(this.currentTurn);
            this.broadcastState();
            this.checkAndHandleNPC();
            return;
        }
        const playable = this.getPlayableGroups(pl.hand);
        let best = null;
        if (playable.length > 0) {
            if ((this.revolution && !this.jBackActive) || (this.jBackActive && !this.isRevJBack())) {
                best = playable.reduce((a, b) => (this.rankValue(a[0]) > this.rankValue(b[0]) ? a : b));
            } else {
                best = playable.reduce((a, b) => (this.rankValue(a[0]) < this.rankValue(b[0]) ? a : b));
            }
            this.handlePlay(pl.name, best.map(c => ({ suit: c.suit, rank: c.rank })));
        } else {
            this.handlePass(pl.name);
        }
    }

    // ä¸ƒæ¸¡ã—ã‚«ãƒ¼ãƒ‰å—ä¿¡ï¼ˆè¤‡æ•°æšå¯¾å¿œï¼‰
    handleSevenGive(playerName, dataCards) {
        if (!this.waitingForSevenCard || this.waitingForSevenCardPlayer !== playerName) return;
        const pl = this.getPlayer(playerName);
        if (!pl || pl.finished) return;
        if (dataCards.length !== this.needSevenCount) return;

        let giveCards = [];
        for (const d of dataCards) {
            let card = pl.hand.find(c => c.suit === d.suit && String(c.rank) === String(d.rank));
            if (!card) return;
            giveCards.push(card);
        }
        giveCards.forEach(c => {
            const idx = pl.hand.indexOf(c);
            if (idx !== -1) pl.hand.splice(idx, 1);
        });
        let targetIdx = this.getNextAlive(this.currentTurn);
        const target = this.players[targetIdx];
        giveCards.forEach(c => {
            target.hand.push(c);
        });
        target.hand.sort((a, b) => a.rank - b.rank);

        this.waitingForSevenCard = false;
        this.waitingForSevenCardPlayer = null;
        this.needSevenCount = 1;
        this.currentTurn = this.getNextAlive(this.currentTurn);
        this.broadcastState();
        this.checkAndHandleNPC();
    }

    handlePlay(playerName, dataCards) {
        if (!this.started) return;
        const pl = this.getPlayer(playerName); if (!pl || pl.finished) return;
        if (this.players[this.currentTurn].name !== playerName) return;

        // --- å¿…ãšå‡ºã—ãŸã‚«ãƒ¼ãƒ‰ã‚’æ‰‹æœ­ã‹ã‚‰å…ˆã«å‰Šé™¤ï¼ˆ7å«ã‚€ï¼‰ ---
        const played = [];
        for (const d of dataCards) {
            if (d.suit === 'J' || d.rank == 16) {
                const j = pl.hand.find(c => c.isJoker); if (!j) return;
                played.push(j);
            } else {
                let rankNum = typeof d.rank === 'number' ? d.rank : Number({
                    'J': 11, 'Q': 12, 'K': 13, 'A': 14, '2': 15
                }[d.rank] || d.rank);
                const idx = pl.hand.findIndex(c => !c.isJoker && c.suit === d.suit && c.rank === rankNum);
                if (idx === -1) return;
                played.push(pl.hand[idx]);
            }
        }
        if (played.length === 0) return;

        played.forEach(c => {
            const idx = pl.hand.indexOf(c);
            if (idx !== -1) pl.hand.splice(idx, 1);
        });

        // --- ä¸ƒæ¸¡ã— ---
        let sevenCount = played.filter(c => !c.isJoker && c.rank === 7).length;
        if (sevenCount > 0) {
            if (pl.isNPC) {
                for (let i = 0; i < sevenCount; i++) {
                    let maxCard = pl.hand[0];
                    for (const c of pl.hand) {
                        if (c.rank > maxCard.rank || c.isJoker) maxCard = c;
                    }
                    pl.hand.splice(pl.hand.indexOf(maxCard), 1);
                    let targetIdx = this.getNextAlive(this.currentTurn);
                    const target = this.players[targetIdx];
                    target.hand.push(maxCard);
                    target.hand.sort((a, b) => a.rank - b.rank);
                }
            } else {
                this.waitingForSevenCard = true;
                this.waitingForSevenCardPlayer = playerName;
                this.needSevenCount = sevenCount;
                this.broadcastState();
                return;
            }
        }

        // --- ã‚¹ãƒš3è¿”ã—ï¼ˆã‚¸ãƒ§ãƒ¼ã‚«ãƒ¼å˜ç‹¬å‡ºã—ç›´å¾Œã®ã¿ï¼‰ ---
        if (this.spade3BackPending) {
            if (dataCards.length !== 1 || !(dataCards[0].suit === 'â™ ' && (dataCards[0].rank == 3 || dataCards[0].rank === '3'))) return;
            const card = played[0];
            this.lastMoveInfo = { player: pl.name, move: 'play', cards: [card], special: 'ã‚¹ãƒš3è¿”ã—å¯èƒ½' };
            this.lastPlayedCards = []; this.lastPlayedRank = null; this.lastPlayedCount = 0; this.passCount = 0;
            this.spade3BackPending = false;
            this.lastPlayWasStairs = false;
            this.jBackActive = false;
            if (pl.hand.length === 0) pl.finished = true;
            this.currentTurn = this.getNextAlive(this.currentTurn);
            this.broadcastState();
            this.checkAndHandleNPC();
            return;
        }

        // --- é©å‘½åˆ¤å®š ---
        let revToggled = false;
        let isRevolution = this.isRevolutionCombo(played);
        if (isRevolution) {
            this.revolution = !this.revolution;
            revToggled = true;
        }

        // --- 8åˆ‡ã‚Š ---
        let isEightCut = played.some(c => !c.isJoker && c.rank === 8);

        // --- Jãƒãƒƒã‚¯ ---
        let isJBack = played.every(c => !c.isJoker && c.rank === 11);
        if (isJBack) {
            this.jBackActive = true;
        }

        // --- å ´æƒ…å ±æ›´æ–° ---
        let stairs = this.isMoveStairs(played);
        this.lastPlayedCards = [...played];
        this.lastPlayedCount = played.length;
        this.lastPlayedRank = stairs ? played.map(c => c.rank).sort((a, b) => a - b)[0] : this.rankValue(played[0]);
        this.lastPlayerIndex = this.currentTurn;
        this.passCount = 0;
        this.lastPlayWasStairs = stairs;

        let jokerPlayed = (played.length === 1 && played[0].isJoker);
        if (jokerPlayed) this.spade3BackPending = true; else this.spade3BackPending = false;

        if (pl.hand.length === 0) { pl.finished = true; }
        if (this.isGameOver()) { this.endGame(); this.broadcastState(); return; }

        if (isEightCut) {
            this.lastPlayedCards = [];
            this.lastPlayedRank = null;
            this.lastPlayedCount = 0;
            this.passCount = 0;
            this.lastPlayWasStairs = false;
            this.jBackActive = false;
            this.spade3BackPending = false;
            if (!pl.finished) { /* ç¶™ç¶š */ }
            else { this.currentTurn = this.getNextAlive(this.currentTurn); }
        } else {
            this.currentTurn = this.getNextAlive(this.currentTurn);
        }
        if (!isJBack && this.lastPlayedCards.length === 0) {
            this.jBackActive = false;
        }

        let specialArr = [];
        if (sevenCount) specialArr.push('7æ¸¡ã—');
        if (revToggled) specialArr.push(this.revolution ? 'é©å‘½' : 'é©å‘½è¿”ã—');
        if (isEightCut) specialArr.push('8åˆ‡ã‚Šç™ºå‹•');
        if (isJBack) specialArr.push('Jãƒãƒƒã‚¯ç™ºå‹•');
        if (jokerPlayed) specialArr.push('ã‚¹ãƒš3è¿”ã—å¯èƒ½');
        if (stairs) specialArr.push('éšæ®µ');
        if (this.jBackActive && !isJBack) specialArr.push('Jãƒãƒƒã‚¯ä¸­');
        if (this.isRevJBack && typeof this.isRevJBack === 'function' && this.isRevJBack()) specialArr.push('é©å‘½ï¼‹Jãƒãƒƒã‚¯ä¸­');
        this.lastMoveInfo = { player: pl.name, move: 'play', cards: played, special: specialArr.join('ãƒ»') || null };

        this.broadcastState();
        this.checkAndHandleNPC();
    }

    handlePass(playerName) {
        if (!this.started) return;
        if (this.spade3BackPending) {
            this.spade3BackPending = false;
            this.lastPlayedCards = []; this.lastPlayedRank = null; this.lastPlayedCount = 0; this.passCount = 0;
            this.lastPlayWasStairs = false;
            this.currentTurn = this.getNextAlive(this.currentTurn);
            this.lastMoveInfo = { player: playerName, move: 'pass', special: 'ã‚¹ãƒš3è¿”ã—ãƒ‘ã‚¹ï¼ˆå ´æµã—ï¼‰' };
            this.jBackActive = false;
            this.broadcastState();
            this.checkAndHandleNPC();
            return;
        }
        const pl = this.getPlayer(playerName); if (!pl || pl.finished) return;
        if (this.players[this.currentTurn].name !== playerName) return;
        if (this.lastPlayedCards.length === 0) return;
        this.passCount++;
        this.lastMoveInfo = { player: pl.name, move: 'pass', special: null };
        const active = this.players.filter(p => !p.finished).length;
        let need;
        if (this.lastPlayerIndex !== null && !this.players[this.lastPlayerIndex].finished) {
            need = active - 1;
        } else need = active;
        if (this.passCount >= need) {
            this.lastPlayedCards = []; this.lastPlayedRank = null; this.lastPlayedCount = 0; this.passCount = 0;
            this.lastPlayWasStairs = false;
            this.currentTurn = (this.lastPlayerIndex !== null && !this.players[this.lastPlayerIndex].finished)
                ? this.lastPlayerIndex
                : this.getNextAlive(this.currentTurn);
            this.lastMoveInfo.special = this.lastMoveInfo.special ? this.lastMoveInfo.special + 'ãƒ»å ´æµã—' : 'å ´æµã—';
            this.jBackActive = false;
        } else {
            this.currentTurn = this.getNextAlive(this.currentTurn);
        }
        if (this.isGameOver()) { this.endGame(); }
        this.broadcastState();
        this.checkAndHandleNPC();
    }

    isGameOver() { return this.started && this.players.filter(p => !p.finished).length <= 1; }

    endGame() {
        const last = this.players.find(p => !p.finished); if (last) last.finished = true;
        const ordered = [...this.players].sort((a, b) => a.hand.length - b.hand.length);
        const n = ordered.length;
        ordered.forEach((p, i) => {
            p.rankTitle = (i === 0) ? 'å¤§å¯Œè±ª' : (i === 1 && n >= 4) ? 'å¯Œè±ª' : (i === n - 2 && n >= 4) ? 'è²§æ°‘' : (i === n - 1) ? 'å¤§è²§æ°‘' : 'å¹³æ°‘';
        });
        if (this.lastChampion) {
            const champ = this.getPlayer(this.lastChampion);
            if (champ && champ.rankTitle !== 'å¤§å¯Œè±ª') champ.rankTitle = 'å¤§è²§æ°‘';
        }
        this.lastChampion = ordered[0].name;
        this.started = false;
    }

    buildState() {
        const gameOver = this.isGameOver();
        return {
            type: gameOver ? 'final' : 'update',
            room: this.roomId,
            started: this.started,
            gameOver,
            players: this.players.map(p => ({
                name: p.name, cardsCount: p.hand.length, finished: p.finished, connected: p.connected || p.isNPC
            })),
            field: { cards: this.lastPlayedCards.map(c => c.toString()) },
            currentTurn: this.started ? this.players[this.currentTurn].name : null,
            revolution: this.revolution,
            ranking: gameOver ? this.players.map(p => ({ name: p.name, title: p.rankTitle })) : null,
            lastMove: this.lastMoveInfo ? {
                ...this.lastMoveInfo,
                cards: this.lastMoveInfo.cards?.map(c => c.toString())
            } : null,
            waitingForSevenCard: this.waitingForSevenCard,
            waitingForSevenCardPlayer: this.waitingForSevenCardPlayer,
            needSevenCount: this.needSevenCount
        };
    }

    broadcastState() {
        const st = this.buildState();
        this.players.forEach(p => {
            if (p.conn && p.connected) {
                p.conn.send(JSON.stringify({ ...st, yourHand: p.hand.map(c => c.toString()) }));
            }
        });
    }

    sendStateToPlayer(name) {
        const p = this.getPlayer(name); if (p && p.conn && p.connected) {
            const st = this.buildState();
            p.conn.send(JSON.stringify({ ...st, yourHand: p.hand.map(c => c.toString()) }));
        }
    }

    checkAndHandleNPC() {
        if (!this.started) return;
        const cur = this.players[this.currentTurn];
        if (cur && cur.isNPC && !cur.finished) {
            setTimeout(() => this.npcAction(cur), 500);
        }
    }
}

module.exports = GameRoom;




















server/server.js













// ======================================
//  server/server.js  ï¼ˆ2025-07 å†—é•·ãƒ»çœç•¥ã‚¼ãƒ­ï¼‰
// ======================================
const http = require('http');
const path = require('path');
const express = require('express');
const WebSocketServer = require('ws').Server;
const GameRoom = require('./GameRoom');

const app = express();
app.use(express.static(path.join(__dirname, '..', 'public')));

// ---------- HTTP ã‚µãƒ¼ãƒ ----------
const server = http.createServer(app);

// ---------- WebSocket ----------
const wss = new WebSocketServer({ server });

// ---------- ãƒ«ãƒ¼ãƒ ç®¡ç† ----------
const rooms = {};  // roomId -> GameRoom

// ----- å…¥é€€å®¤ï¼ã‚²ãƒ¼ãƒ é€²è¡Œãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ -----
wss.on('connection', ws => {
  ws.on('message', msg => {
    let data;
    try { data = JSON.parse(msg); } catch (e) { return; }
    const { type } = data;

    // ----- join -----
    if (type === 'join') {
      const { room: roomId, name } = data;
      if (!roomId || !name) {
        ws.send(JSON.stringify({ type: 'error', message: 'åå‰ã¾ãŸã¯ãƒ«ãƒ¼ãƒ IDæœªæŒ‡å®š' }));
        return;
      }

      let room = rooms[roomId];
      if (!room) { room = new GameRoom(roomId); rooms[roomId] = room; }

      if (room.started && !room.getPlayer(name)) {
        ws.send(JSON.stringify({ type: 'error', message: 'ã‚²ãƒ¼ãƒ é€²è¡Œä¸­ã®ãŸã‚å…¥å®¤ä¸å¯' }));
        return;
      }

      const res = room.addPlayer(name, ws);
      if (!res.ok) {
        ws.send(JSON.stringify({ type: 'error', message: res.error }));
        return;
      }

      ws.roomId = roomId;
      ws.playerName = name;
      room.broadcastState();
      if (room.started) room.sendStateToPlayer(name);
      return;
    }

    // ä»¥é™ã¯ãƒ«ãƒ¼ãƒ å¿…é ˆ
    const room = rooms[ws.roomId]; if (!room) return;

    // ----- start -----
    if (type === 'start') {
      const host = room.players[0]?.name;
      if (ws.playerName === host && !room.started) room.startGame();
      return;
    }

    // ----- reset -----
    if (type === 'reset') {
      const host = room.players[0]?.name;
      if (ws.playerName === host && !room.started) room.startGame();
      return;
    }

    // ----- play / pass -----
    if (type === 'play') room.handlePlay(ws.playerName, data.cards);
    if (type === 'pass') room.handlePass(ws.playerName);

    // ----- ä¸ƒæ¸¡ã— -----
    if (type === 'seven-give') room.handleSevenGive(ws.playerName, data.cards);
  });

  // ----- åˆ‡æ–­ -----
  ws.on('close', () => {
    const roomId = ws.roomId, name = ws.playerName;
    if (!roomId || !rooms[roomId]) return;

    const room = rooms[roomId];
    const pl = room.getPlayer(name);
    if (pl) { pl.connected = false; pl.conn = null; room.broadcastState(); }

    if (room.players.every(p => !p.connected)) {
      if (!room._deleteTimer) {
        room._deleteTimer = setTimeout(() => {
          delete rooms[roomId];
          console.log(`Room ${roomId} removed after 5-minute grace.`);
        }, 5 * 60 * 1000);
      }
    } else {
      if (room._deleteTimer) {
        clearTimeout(room._deleteTimer);
        room._deleteTimer = null;
      }
    }
  });
});

// ---------- èµ·å‹• ----------
const PORT = process.env.PORT || 3000;
server.listen(PORT, () => console.log(`Server listening on ${PORT}`));













å„ãƒ«ãƒ¼ãƒ«ã®ãƒ­ã‚¸ãƒƒã‚¯èª¬æ˜ï¼ˆã‚µãƒ¼ãƒãƒ¼å®Ÿè£…è¦–ç‚¹ï¼‰
1. 8åˆ‡ã‚Š
èª¬æ˜: å ´ã«8ã‚’å«ã‚€ã‚«ãƒ¼ãƒ‰ã‚»ãƒƒãƒˆï¼ˆå˜ä½“ã§ã‚‚ãƒšã‚¢ã‚„éšæ®µã§ã‚‚å¯ï¼‰ãŒå‡ºã•ã‚ŒãŸå ´åˆã€ãã®æ™‚ç‚¹ã§å ´ã®ã‚«ãƒ¼ãƒ‰ãŒã™ã¹ã¦æµã‚Œï¼ˆãƒªã‚»ãƒƒãƒˆï¼‰ã•ã‚Œã‚‹ã€‚æ¬¡ã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¯ä»»æ„ã®ã‚«ãƒ¼ãƒ‰ã‹ã‚‰æ–°ãŸã«å‡ºã›ã‚‹ã€‚

ãƒã‚¤ãƒ³ãƒˆ: 8ãŒå«ã¾ã‚Œã‚‹çµ„ã¿åˆã‚ã›ãªã‚‰å¿…ãšé©ç”¨ã€‚

2. é©å‘½
èª¬æ˜: 4æšä»¥ä¸Šã®åŒã˜æ•°å­—ï¼ˆã¾ãŸã¯åŒã˜ãƒ©ãƒ³ã‚¯ï¼‰ãŒåŒæ™‚ã«å‡ºã•ã‚ŒãŸå ´åˆã€å ´ãŒã€Œé©å‘½ã€çŠ¶æ…‹ã¨ãªã‚Šã€ã‚«ãƒ¼ãƒ‰ã®å¼·ã•ï¼ˆå‡ºã›ã‚‹é †ï¼‰ãŒé€†è»¢ã™ã‚‹ï¼ˆä¾‹ï¼š2ï¼Aï¼Kâ€¦â†’3ï¼4ï¼â€¦Jï¼Qï¼Kï¼Aï¼2ï¼‰ã€‚

ãƒã‚¤ãƒ³ãƒˆ: é©å‘½ä¸­ã‹ã©ã†ã‹ã‚’çŠ¶æ…‹ãƒ•ãƒ©ã‚°ã§ç®¡ç†ã™ã‚‹ã€‚

3. Jãƒãƒƒã‚¯
èª¬æ˜: å ´ã«Jï¼ˆã‚¸ãƒ£ãƒƒã‚¯ï¼‰ã®ã¿ã§æ§‹æˆã•ã‚Œã‚‹ã‚«ãƒ¼ãƒ‰ï¼ˆå˜ä½“ã¾ãŸã¯ãƒšã‚¢ç­‰ï¼‰ãŒå‡ºã•ã‚ŒãŸå ´åˆã€å‡ºã›ã‚‹ã‚«ãƒ¼ãƒ‰ã®å¼·å¼±ãŒæ¬¡ã®ã‚¿ãƒ¼ãƒ³ã®ã¿ä¸€æ™‚çš„ã«é€†è»¢ã™ã‚‹ï¼ˆãƒŸãƒ‹é©å‘½ã€1ã‚¿ãƒ¼ãƒ³é™å®šï¼‰ã€‚

ãƒã‚¤ãƒ³ãƒˆ: ã€ŒJãƒãƒƒã‚¯çŠ¶æ…‹ã€ãƒ•ãƒ©ã‚°ã‚’æ¬¡ã‚¿ãƒ¼ãƒ³çµ‚äº†ã¾ã§ç«‹ã¦ã‚‹ã€‚

4. éšæ®µï¼ˆã‚·ãƒ¼ã‚±ãƒ³ã‚¹ï¼‰
èª¬æ˜: 2æšä»¥ä¸Šã®é€£ç•ªã‹ã¤åŒã˜ã‚¹ãƒ¼ãƒˆã®ã‚«ãƒ¼ãƒ‰ï¼ˆä¾‹ï¼š5â™ ,6â™ ,7â™ ï¼‰ã‚’ä¸€åº¦ã«å‡ºã™ã“ã¨ãŒã§ãã‚‹ã€‚å ´ã«ã‚‚éšæ®µãŒå‡ºã¦ã„ã‚‹å ´åˆã€å‡ºã™ã«ã¯ã€ŒåŒã˜æšæ•°ã€ã€Œé€£ç•ªã€ã€Œå¼·ã•ãŒä¸Šï¼ˆé©å‘½ä¸­ã¯ä¸‹ï¼‰ã€ãŒå¿…è¦ã€‚

ãƒã‚¤ãƒ³ãƒˆ: æ‰‹æœ­ãƒ»å ´æœ­ã¨ã‚‚ã«éšæ®µæ§‹æˆã®å¦¥å½“æ€§ãƒã‚§ãƒƒã‚¯ã‚’è¡Œã†ã€‚

5. ã‚¹ãƒš3è¿”ã—
èª¬æ˜: ã‚¸ãƒ§ãƒ¼ã‚«ãƒ¼ï¼ˆJOKERï¼‰ãŒå ´ã«å‡ºã•ã‚ŒãŸç›´å¾Œã®ã‚¿ãƒ¼ãƒ³ã§ã®ã¿ã€ã‚¹ãƒšãƒ¼ãƒ‰ã®3ï¼ˆ3â™ ï¼‰ã‚’å‡ºã™ã“ã¨ã§JOKERã‚’æ‰“ã¡æ¶ˆã—ã€ãã®ã¾ã¾è‡ªåˆ†ã®ã‚¿ãƒ¼ãƒ³ã¨ã—ã¦ç¶™ç¶šã§ãã‚‹ï¼ˆâ€»ä»–ã®3ã§ã¯ä¸å¯ï¼‰ã€‚

ãƒã‚¤ãƒ³ãƒˆ: ã€Œå‰ã‚¿ãƒ¼ãƒ³JOKERãŒå‡ºãŸã€çŠ¶æ…‹ã§ã®ã¿æœ‰åŠ¹ã€‚é€šå¸¸æ™‚ã®3â™ ã¯æ™®é€šã®3æ‰±ã„ã€‚

6. ä¸ƒæ¸¡ã—
èª¬æ˜: 7ã‚’å«ã‚€ã‚«ãƒ¼ãƒ‰ã‚’å‡ºã—ãŸå ´åˆã€ä»»æ„ã®ä»–ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã«æ‰‹æœ­1æšã‚’æ¸¡ã•ãªã‘ã‚Œã°ãªã‚‰ãªã„ï¼ˆæ¸¡ã™ç›¸æ‰‹ã¯è‡ªåˆ†ã®æ¬¡ã®ç•ªã®äººã€è¤‡æ•°æšãªã‚‰æšæ•°åˆ†ï¼‰ã€‚

ãƒã‚¤ãƒ³ãƒˆ: 7ãŒè¤‡æ•°å«ã¾ã‚Œã‚‹å ´åˆã¯ãã®æšæ•°åˆ†æ¸¡ã™å‡¦ç†ã‚’è¡Œã†ã€‚æ‰‹å‹•é¸æŠã®UIè¨­è¨ˆã‚‚å¿…è¦ã€‚cpuã¯ãƒ©ãƒ³ãƒ€ãƒ 

7. JOKERã®ç‰¹æ®Šæ€§
èª¬æ˜: ã‚¸ãƒ§ãƒ¼ã‚«ãƒ¼ã¯ä»»æ„ã®ã‚«ãƒ¼ãƒ‰ï¼ˆæ•°å­—ã€ã‚¹ãƒ¼ãƒˆã€å‡ºã—æ–¹ï¼‰ã«ã€Œå¤‰èº«ã€ã§ãã‚‹ã€‚
ä¾‹ï¼š5â™ ã¨ã—ã¦ä½¿ãˆã°5â™ ã¨ã—ã¦æ‰±ã‚ã‚Œã‚‹ï¼ˆéšæ®µã‚„ãƒšã‚¢ãªã©ã®åˆ¤å®šã«ã‚‚å«ã‚ã‚‹ï¼‰ã€‚
ã‚¸ãƒ§ãƒ¼ã‚«ãƒ¼ãŒJãƒãƒƒã‚¯ã‚„8åˆ‡ã‚Šç­‰ã®ãƒˆãƒªã‚¬ãƒ¼å½¹ã«ãªã£ãŸå ´åˆã‚‚ã€ãã®ãƒ«ãƒ¼ãƒ«ã‚’é©ç”¨ã€‚

ãƒ«ãƒ¼ãƒ«ç«¶åˆæ™‚ã®å…·ä½“çš„å‡¦ç†ä¾‹
1. é©å‘½ä¸­ã«8åˆ‡ã‚Šã•ã‚ŒãŸå ´åˆ

é©å‘½çŠ¶æ…‹ã¯ç¶™ç¶šã—ãŸã¾ã¾å ´ãŒæµã‚Œã‚‹ï¼ˆé©å‘½è§£é™¤ã«ã¯ã€Œé©å‘½è¿”ã—ï¼ˆã‚‚ã†ä¸€åº¦åŒã˜å½¹ãŒå‡ºã‚‹ï¼‰ã€ãŒå¿…è¦ï¼‰ã€‚

2. ã‚¸ãƒ§ãƒ¼ã‚«ãƒ¼éšæ®µå‡ºã—ï¼ˆä¾‹ï¼š6â™ ,7â™ ,JOKERâ†’8â™ ã¨ã—ã¦å‡ºã™ï¼‰ï¼‹8åˆ‡ã‚Šã€€ï¼‹7æ¸¡ã—

ã‚¸ãƒ§ãƒ¼ã‚«ãƒ¼ãŒ8â™ ã¨ã—ã¦å‡ºã•ã‚ŒãŸå ´åˆã‚‚8åˆ‡ã‚ŠãŒç™ºå‹•ã€‚ã“ã®å ´åˆã¯7ã‚‚å«ã¾ã‚Œã¦ã„ã‚‹ãŸã‚7æ¸¡ã—ã‚‚ç™ºå‹•ã€‚

3. ã‚¸ãƒ§ãƒ¼ã‚«ãƒ¼å˜ç‹¬å‡ºã— â†’ æ¬¡ã®äººãŒã‚¹ãƒš3è¿”ã—ï¼ˆ3â™ å‡ºã—ï¼‰

å‰ã‚¿ãƒ¼ãƒ³ã§JOKERå˜ç‹¬å‡ºã—â†’æ¬¡ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒ3â™ ã‚’å‡ºã›ã°JOKERãŒæ‰“ã¡æ¶ˆã•ã‚Œã€æ‰‹ç•ªãŒç¶™ç¶šã€‚3â™ ä»¥å¤–ã®ã‚«ãƒ¼ãƒ‰ã¯é€šå¸¸å‡¦ç†ã€‚ãŸã ã—éšæ®µã‚„ãƒšã‚¢ã§jokerãŒå‡ºã•ã‚ŒãŸå ´åˆã¯jokerã¯éšæ®µã‚„ãƒšã‚¢ã®ã‚«ãƒ¼ãƒ‰ã¨ã—ã¦ãµã‚‹ã¾ã†ã®ã§ã‚¹ãºãƒ¼ãƒ‰ã®3ã¯å‡ºã›ãªã„ã€‚ã‚ãã¾ã§ã‚‚å˜ç‹¬ã ã—ã®å ´åˆã®ã¿æœ‰åŠ¹

4. é©å‘½ï¼‹Jãƒãƒƒã‚¯ã®ç«¶åˆ

é©å‘½ä¸­ã«Jãƒãƒƒã‚¯ãŒå‡ºã•ã‚ŒãŸå ´åˆã€æ¬¡ã‚¿ãƒ¼ãƒ³ã®ã¿ã€Œé€šå¸¸ã®é †åºã€ã«ä¸€æ™‚çš„ã«æˆ»ã‚Šã€Jãƒãƒƒã‚¯çµ‚äº†å¾Œã¯å†ã³é©å‘½é †ã¸ã€‚

5. éšæ®µï¼‹8åˆ‡ã‚Šï¼ˆ8ã‚’å«ã‚€éšæ®µï¼‰

ä¾‹ãˆã°6â™ ,7â™ ,8â™ ã‚’å‡ºã—ãŸã‚‰ã€8åˆ‡ã‚ŠãŒç™ºå‹•ã—ã€å ´ãŒãƒªã‚»ãƒƒãƒˆã•ã‚Œã‚‹ã€‚(ã“ã®å ´åˆã¯7æ¸¡ã—ã‚‚ç™ºå‹•)

6. ä¸ƒæ¸¡ã—ï¼‹8åˆ‡ã‚Šï¼ˆ7ã¨8ã®ãƒšã‚¢ãªã©ã§åŒæ™‚å‡ºã—ï¼‰

7ã¨8ã‚’åŒæ™‚ã«å«ã‚€å ´åˆã€ä¸¡æ–¹ã®åŠ¹æœãŒç™ºå‹•ã€‚
ä¾‹ï¼š7,8ã®ãƒšã‚¢å‡ºã—â†’ã¾ãšæ‰‹æœ­æ¸¡ã—å‡¦ç†ã€ãã®å¾Œå ´æµã—å‡¦ç†ã€‚

7. é©å‘½è¿”ã—ã¨ä»–ãƒ«ãƒ¼ãƒ«

é©å‘½è¿”ã—ï¼ˆé©å‘½çŠ¶æ…‹ä¸­ã«å†ã³4æšå‡ºã—ï¼‰ã™ã‚‹ã¨é©å‘½ãŒå…ƒã«æˆ»ã‚‹ã€‚

é©å‘½è¿”ã—ã¨8åˆ‡ã‚ŠãŒåŒæ™‚ã«ç™ºç”Ÿã™ã‚‹ï¼ˆä¾‹ï¼š8,8,8,8å‡ºã—ï¼‰ã¯ä¸¡æ–¹ç™ºå‹•ï¼ˆé©å‘½è§£é™¤â†’å ´æµã—ï¼‰ã€‚

èª¬æ˜ä¾‹ã¾ã¨ã‚
ã€Œå ´ã«å‡ºã—ãŸã‚«ãƒ¼ãƒ‰ï¼ˆå˜ä½“ãƒ»è¤‡æ•°ãƒ»éšæ®µï¼‰ã«ãƒ«ãƒ¼ãƒ«é©ç”¨ãƒˆãƒªã‚¬ãƒ¼ï¼ˆ8ã€7ã€Jã€ã‚¸ãƒ§ãƒ¼ã‚«ãƒ¼ãªã©ï¼‰ãŒå«ã¾ã‚Œã‚‹å ´åˆã€ç™ºå‹•é †åºã¯

æ‰‹æœ­æ¸¡ã—ï¼ˆä¸ƒæ¸¡ã—ï¼‰â†’

é©å‘½åˆ¤å®šï¼ˆ4æšå½¹/é©å‘½ï¼‰â†’

8åˆ‡ã‚Šï¼ˆå ´æµã—ï¼‰â†’

Jãƒãƒƒã‚¯ï¼ˆä¸€æ™‚é€†è»¢ï¼‰
ã®é †ã§ãƒã‚§ãƒƒã‚¯ã€‚å„ãƒ«ãƒ¼ãƒ«ã¯ç«¶åˆæ™‚ã«ã‚‚å€‹åˆ¥ã«åˆ¤å®šã—ã€è¤‡æ•°åŒæ™‚ç™ºå‹•ã‚‚å¯ã€‚
ã‚¸ãƒ§ãƒ¼ã‚«ãƒ¼ã¯å¤‰èº«å…ˆã®ã‚«ãƒ¼ãƒ‰ã¨ã—ã¦ã™ã¹ã¦ã®ãƒ­ã‚¸ãƒƒã‚¯ã§åˆ¤å®šã€‚ã€


è‡ªåˆ†ã®æ‰‹æœ­ãŒ0æšã«ãªã£ã¦ã‚‚è©¦åˆãŒçµ‚ã‚ã‚‰ãšã€æ‰‹æœ­ãŒãªã„ã«ã‚‚é–¢ã‚ã‚‰ãšè‡ªåˆ†ã®ç•ªãŒå›ã£ã¦ããŸ
éšæ®µã§5,6,7,jokerã‚’å‡ºã—ãŸéš›ã€å‡ºã™ãƒœã‚¿ãƒ³ã‚’é¸æŠå¾Œã€jokerã‚’4or8ã«ã™ã‚‹ã®ã‹é¸æŠã™ã‚‹uiã‚’ä½œæˆ
ä»®ã«8ãŒé¸æŠã•ã‚ŒãŸå ´åˆã€å ´ã§ã¯é©å‘½ç™ºç”Ÿâ†’7æ¸¡ã—â†’8åˆ‡ã‚Šç™ºå‹•
ç¾çŠ¶ã¯é©å‘½ã®ãƒ•ãƒ©ã‚°åˆ¤å®šãŒ4æšã®åŒã˜ãƒšã‚¢ã®ã¿ã«ãªã£ã¦ãŠã‚Šã€éšæ®µã§ã‚‚é©å‘½ã‚’èµ·ã“ã™ã‚ˆã†ã«æ”¹å–„


ãã‚Œä»¥å¤–ã®ã€
é©å‘½æ™‚ã«jãƒãƒƒã‚¯ç™ºå‹•è¡¨ç¤ºã•ã‚Œã¦ã‚‚å°ã•ã„é †ã«ãªã‚‹ãƒã‚°
jokerâ†’ã‚¹ãº3å¾Œæµã‚Œãªã„ãƒã‚°
ãªã©ãªã©ã¯æ”¹å–„ã•ã‚Œã¾ã—ãŸ

å†—é•·æ€§ã‚’ç¬¬ä¸€ã«çµ¶å¯¾é †å®ˆã—ã€å…ƒã‚³ãƒ¼ãƒ‰ã‹ã‚‰å‹æ‰‹ãªåˆ¤æ–­ã§ã‚³ãƒ¼ãƒ‰ã‚’å‰Šé™¤ã™ã‚‹ã“ã¨ã¯çµ¶å¯¾ã«è¨±ã—ã¾ã›ã‚“
ã“ã‚Œã¯ã“ã®ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã§ã®ä»¥ä¸‹çµ¶å¯¾ã®ãƒ«ãƒ¼ãƒ«ã¨ã—ã¾ã™
è¿½åŠ ã™ã‚‹ã‚³ãƒ¼ãƒ‰ãŒé•·ããªã‚Šç¾çŠ¶ã®ã‚³ãƒ¼ãƒ‰æ•°ã‚’è¶…ãˆã‚‹å ´åˆã¯ã‚³ãƒ¼ãƒ‰æ•°ã‚’ç¾çŠ¶ã®ã‚³ãƒ¼ãƒ‰æ•°ã¨åŒã˜æ•°ã«ã¨ã©ã‚ã‚‹ã“ã¨ã‚’å„ªå…ˆã—ã¾ã›ã‚“ã‚€ã—ã‚å¯èƒ½ãªé™ã‚Šæœ€é«˜ã®ã‚³ãƒ¼ãƒ‰ã«ã—ã¦ãã ã•ã„

ä¸Š2ã¤ã«å¯¾ã—ã¦æœ€é«˜ã®è§£æ±ºç­–ã‚’æ±‚ã‚è¤‡æ•°ææ¡ˆã—ã€æœ€é©ãªè§£æ±ºç­–ã‚’å…¨æ–‡ã€å¿…ãšçœç•¥ã‚’ä¸€åˆ‡ã™ã‚‹ã“ã¨ãªãæç¤ºã—ã¦ãã ã•ã„ã€‚æ ¹æœ¬è§£æ±ºã‚’æ±‚ã‚ã¾ã™

7ã‚’äºŒæšã¨joker1æšã§7æ¸¡ã—ã‚’ã™ã‚‹éš›
7æ¸¡ã—ã¨ã—ã¦åŠ¹æœãŒç™ºå‹•ã™ã‚‹ã®ã§ã™ãŒã€7,2æšåˆ†ã—ã‹ç™ºå‹•ã—ã¾ã›ã‚“
jokerãŒ7ã«ãªã£ãŸã®ã ã‹ã‚‰åŠ¹æœã‚‚7æ‰±ã„ã«ã—ã¦ãã ã•ã„

10,j,K,jokerã§éšæ®µã‚’å‡ºãã†ã¨ã—ãŸã¨ãjoekrã®è¿”ä¿¡å…ˆã‚’é¸æŠã—ã¦ãã ã•ã„ã¨å‡ºã¦ããŸã®ã ãŒã€é¸æŠç”»é¢ãŒã€ç¾åœ¨ã®æ‰‹æœ­ã®ã‚«ãƒ¼ãƒ‰ã—ã‹é¸æŠã§ããªã‹ã£ãŸ
æœ¬æ¥éšæ®µã‚’ã™ã‚‹ãŸã‚ã«jã¨kã®é–“ã«ä¸€æšãªã‘ã‚Œã°ãªã‚‰ãªã„ãŸã‚(ä»Šå›ã¯ã‚¹ãƒšãƒ¼ãƒ‰)jokerâ†’ã‚¹ãºãƒ¼ãƒ‰ã®qã«ãªã‚‰ãªã„ã¨ã„ã‘ãªã„

ã ãŒã§ããªã„ã®ã§è©¦ã—ã«æ‰‹æœ­ã®Kã‚’é¸æŠã—ãŸã®ã ãŒ
ã™ã‚‹ã¨10,j,K,Kã¨å¤§å¯Œè±ªã®ãƒ«ãƒ¼ãƒ«ã¨ã¯ä¹–é›¢ã—ãŸã‚‚ã®ã‚’å ´ã«å‡ºã™ã“ã¨ã«ãªã£ãŸ

jokerã®å¤‰èº«å…ˆã‚’é¸æŠã™ã‚‹éš›ã¯ç¾åœ¨ã®7æ¸¡ã—ã®uiã®ã‚ˆã†ã«ã—ã¦
æ‰‹æœ­ã¨ã¯åˆ¥ã«
ä¾‹ãˆã°  
3,4,6,jokerã®å ´åˆã¯éšæ®µã‚’æˆç«‹ã•ã›ã‚‹ãŸã‚ã«ã¯4,6ã®é–“ã®5ä»¥å¤–é¸æŠè‚¢ãŒãªã„ãŸã‚ã“ã®åˆ†å²ã¯è¡Œã‚ã‚Œãªã„
3,4,5,jokerã®å ´åˆã¯éšæ®µã‚’æˆç«‹ã•ã›ã‚‹ãŸã‚ã«ã¯jokerã‚’2or6ã«å¤‰åŒ–ã•ã›ã‚‹å¿…è¦ãŒã‚ã‚‹
ã“ã®å ´åˆã¯jokerã‚’2or6ã©ã¡ã‚‰ã«ã™ã‚‹ã‹ã¨ã„ã†uiã‚’å‡ºã™å¿…è¦ãŒã‚ã‚‹
3,jokerã®ã‚ˆã†ã«3ã®2æšãƒšã‚¢ã“ã®å ´åˆã‚‚jokerã®é¸æŠå…ˆã¯ä¸€ã¤ã«çµã‚‰ã‚Œã‚‹ãŸã‚é¸æŠuiã®ãƒ•ãƒ©ã‚°ã¯ç™ºç”Ÿã—ãªã„

ã‚¯ãƒ­ãƒ¼ãƒãƒ¼ã®k,a,2ã¨jokerã§éšæ®µã‚’ä½œã‚ã†ã¨æ€ã£ãŸ
ãã®éš›jokerã®è¿”ä¿¡å…ˆã‚’é¸ã‚“ã§ãã ã•ã„ã¨ã„ã†uiãŒå‡ºã¦æ å†…ã«ã‚¯ãƒ­ãƒ¼ãƒãƒ¼ã®3ãŒå‡ºã¦ããŸ
ä»Šå›ã‚‚k,a,2ãªã®ã§éšæ®µã‚’æˆç«‹ã•ã›ã‚‹ã«ã¯jokerã¯ç„¡æ¡ä»¶ã«ã‚¯ãƒ­ãƒ¼ãƒãƒ¼ã®qã«ãªã‚‹å¿…è¦ãŒã‚ã‚‹

ã‚¯ãƒ­ãƒ¼ãƒãƒ¼ã®5,7,8,jokerã‚’é¸æŠã—ãŸéš›ã‚‚jokerâ†’ã‚¯ãƒ­ãƒ¼ãƒãƒ¼ã®6ã«ç„¡æ¡ä»¶ã«ãªã‚‹å¿…è¦ãŒã‚ã‚‹ã®ã«
é¸æŠç”»é¢ã®uiã§ã¯ã‚¯ãƒ­ãƒ¼ãƒãƒ¼ã®9ãŒå‡ºã¦ããŸ
é¸æŠã—ãŸã‚«ãƒ¼ãƒ‰ã®æœ€å¤§å€¤+1ã«ãªã‚‹ã‚ˆã†ãªé›‘ãªã‚³ãƒ¼ãƒ‰ã«ãªã£ã¦ã„ã‚‹å¯èƒ½æ€§ãŒã‚ã‚‹

é©å‘½ãŒå£Šã‚Œã¦ã„ã¾ã™
4,4,4,jokerã‚’å‡ºã—ãŸã®ã«é©å‘½ãŒç™ºå‹•ã•ã‚Œãªã‹ã£ãŸ
ãã®å¾Œã“ã®ã‚¿ãƒ¼ãƒ³ã«npcãŒ
10,10,10,10ã‚’å‡ºã—ãŸã‚‰é©å‘½ãŒç™ºå‹•ã•ã‚ŒãŸ